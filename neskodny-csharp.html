<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.8" />
<title>(Ne)škodný úvod do OOP v jazyce C#</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}


#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>(Ne)škodný úvod do OOP v jazyce C#</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>Lukáš Kotek &lt;<a href="mailto:lukaskotek@gmail.com">lukaskotek@gmail.com</a>&gt;</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip" />
</td>
<td class="content">Tento dokument nemá ambici v žádném slova smyslu suplovat technickou dokumentaci, odborné publikace nebo učebnice, které se zabývají programováním a programovacím jazykem C#. Rovněž není jeho cílem poskytovat dokonale exaktní formulace a definice pojmů ze zmíněné oblasti. Naopak cílí na uživatele (a zde konkrétně na studenty středních škol), kteří do objektového programování zatím pouze jemně vplouvají a potřebují proto nenásilnou formou osvětlit základní pojmy a principy, které s objektovým programování souvisí. Prosím nazírejte na něj s vědomím výše zmíněného.</td>
</tr></table>
</div>
<div style="page-break-after:always"></div>
</div>
</div>
<div class="sect1">
<h2 id="_co_je_to_objektově_orientované_programování">Co je to objektově orientované programování?</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_proč_použít_objektové_programování">Proč použít objektové programování</h3>
<div class="paragraph"><p>Objektově orientované programování (OOP) je o zcela jiném přístupu k programování, než který byl (a v mnoha případech z dobrého důvodu dosud je) používán. Jak jsme se dívali na prvotně na program dříve? Jako na sled po sobě jdoucích pokynů. Čili:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Krok první: udělej to (třeba načti hodnotu do proměnné);
</p>
</li>
<li>
<p>
Krok druhý: udělej ono (umocni prve načtenou proměnnou na druhou);
</p>
</li>
<li>
<p>
Krok třetí: pokud platí A, proveď B (pokud je číslo nenulové, použij ho jako dělitel).
</p>
</li>
</ol></div>
<div class="paragraph"><p>A podobně bychom mohli pokračovat, je to zjevné?</p></div>
<div class="paragraph"><p>Algoritmus jsme popsali vývojovým diagramem, který pro nás byl přesným návodem co kdy a jak udělat. Program pak pro nás byl strukturovaným přepisem tohoto návodu do konkrétního programovacího jazyka (s jeho příkazy a specifickou syntaxí).</p></div>
<div class="paragraph"><p>Pojďme se podívat na objektově orientované programování (je to dlouhý pojem, pojďme si vystačit se zkratkou OOP, platí?). Předně, OOP vůbec neříká, že to, co je v prvním odstavci není pravda. Algoritmus bude vždy posloupností kroků. OOP říká, že se mění náš pohled na program jako takový. Hlavní pro nás už není postup řešení (jak to jde za sebou), ale to s čím vlastně pracujeme (a o co se vlastně jedná, z čeho se to skládá, jak se to chová, jak to popíšeme?).</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Všimli jste si tajemného „ono“? To ono, tajemná věc, o které mluvíme se nazývá objekt.</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="_něco_teorie_k_základní_terminologii">Něco teorie k základní terminologii</h3>
<div class="sect3">
<h4 id="_objekt">Objekt</h4>
<div class="paragraph"><p>Máte tady tedy tajemný pojem objekt. Vůbec není tajemný. Objekt je prvek, kterým se snažíme popsat něco z reálného světa. Co nás napadá? Vezměme těžkou klasiku. Člověka, ale ne ledajakého člověka, vezměme <strong>konkrétního člověka</strong>, spolužáka, kamaráda, např. Igora Nováka (budeme jeho služeb v průběhu textu využívat i dále). Co bychom o něm mohli říct? Třeba, že je nějak vysoký, umí nějaké věci, že když spadne ze schodů bude na to nějak reagovat.</p></div>
<div class="olist arabic"><div class="title">Všimněte si toho hlavního:</div><ol class="arabic">
<li>
<p>
Nás nezajímá jen tak ledajaký člověk (těch je spousta), nás zajímá Igor Novák s konkrétními vlastnostmi schopnosti a dovednostmi. Mohli bychom popsat obecného člověka s přesně definovanými vlastnostmi a schopnostmi? Sotva, každý je něčím specifický. Igor Novák je náš jeden konkrétní objekt.
</p>
</li>
<li>
<p>
Nás nezajímají jen samotné údaje tohoto člověka. Nás nezajímá čistě hodnota cholesterolu, ani výška, ani váha. Ne. Pro nás je zásadní, že je to Igorova hodnota cholesterolu, Igorova výška a Igorova váha. Nejsou to samostatně stojící prvky, pevně se váží k Igorovi, popisují ho, jsou s ním spjaté. Igor je objekt, je jedinečný.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Jeli-to jasné, pojďme se posunout o kousek dále, k zásadnímu pojmu třída.</p></div>
</div>
<div class="sect3">
<h4 id="_třída">Třída</h4>
<div class="paragraph"><p>Už jsme si řekli, že <strong>Igor je objekt</strong>. Že Igor je jedinečný. Ale je tak jedinečný, že bychom ho nemohli k někomu připodobnit? Co o něm víme? Igor je také člověk. Jako já, jako vy. Vy i já máme mnoho společných vlastností. Všichni jsme nějak vysocí, všichni máme nějakou váhu, hodnotu cholesterolu, každý umíme mluvit, ale mluvíme všichni stejně? Rozhodně ne. Co z toho plyne:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Existuje mnoho lidí. Jsou různí, ale mohou mít společné vlastnosti;
</p>
</li>
<li>
<p>
Každý jsme vytvořený podle společného vzoru, každý máme DNA, ale nikdo stejnou.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Všichni známe DNA, platí? Kdo ne, dohledá si na (něco)pedii. Představme si, že je to šablona, podle které jsou vytvářeni konkrétní lidé. Smícháním určitých genů vznikne určitý člověk. Ještě jednou: je mnoho lidí, ale Igor Novák je jen jeden. Všichni lidé jsou ale vytvořeni podle společného vzoru, podle společné šablony. Tím se dostáváme k jádru věci.</p></div>
<div class="paragraph"><p>Vzor? Šablona? Pojďme použít lepší termín: <strong>třída</strong>. Třída je papír, na kterém je napsáno, že každý člověk má být nějak vysoký, má mít nějaký věk, má mít nějaké schopnosti. Jakou výšku? Jaký věk? Jaké schopnosti? To třída netuší. Je to opravdu jen šablona. Jeto prázdný formulář. Má kolonky, ale ty kolonky nejsou vyplněné. Až když je vyplníme, vznikne konkrétní člověk. Vznikne náš Igor.</p></div>
<div class="olist arabic"><div class="title">Tohle je zásadní moment. Tvrdíme, že:</div><ol class="arabic">
<li>
<p>
Igor je objekt (to už jsme tvrdili dříve);
</p>
</li>
<li>
<p>
Že Igor je člověk, které je vytvořený podle šablony, vzoru, formuláře „člověk“.
</p>
</li>
</ol></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Igor je tedy unikátním a neopakovatelným případem člověka. Vyplnili jsme formulář člověk a vznikl Igor. Vyplnili bychom ho jinak a vznikl by Pepa, ještě jinak a měli bychom tu Janu, úplně jinak a měli bychom tu Jamese T. Kirka. Igor je tedy instancí třídy člověk. Co je instance třídy? Je to vyplněný formulář, je to objekt. Objekt je tedy totožný s instanci třídy.</td>
</tr></table>
</div>
</div>
<div class="sect3">
<h4 id="_člen_třídy">Člen třídy</h4>
<div class="paragraph"><p>Tahle pasáž bude stručná. Už víme, kdo je to Igor. Už víme, co je to člověk. Člen třídy nám vypovídá o tom, o jakého člověka se jedná. Je-li člověk formulář, pak člen třídy je konkrétní položkou.</p></div>
<div class="olist arabic"><div class="title">Členové třídy, ale mohou být velice různí:</div><ol class="arabic">
<li>
<p>
Mohou říkat, že člověk má mít nějakou výšku, věk či barvu očí;
</p>
</li>
<li>
<p>
Mohou říkat, že člověk může nějak měnit svůj stav, že člověk nějak koná;
</p>
</li>
<li>
<p>
Mohou říkat, že člověk může nějak reagovat na nějaké události.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Pojďme krok za krokem. První případ nazýváme <strong>vlastností, či atributem</strong> (popisujeme, jaký – a pozor zase se jedná až o konkrétního jedince – člověk je). Igor má modré oči. Druhý případ nazýváme metodou (popisujeme jak se daný člověk projevuje). A zase každý člověk umí hubnout, ale pouze Igor umí hubnout o 5 kg za půl roku. A reakce na události? Představte si, že vás někdo udeří. Každý člověk na to bude reagovat, ale pouze Igor uteče rychlostí 20 km/h směrem na severovýchod za hlasitých výkřiků. Zde jsme u pojmu událost (specifický případ vlastnosti).</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_dědičnost_mezi_třídami">Dědičnost mezi třídami</h3>
<div class="paragraph"><p>Dosud jsme byli na výrazně abstraktní rovině. Pojďme se tedy (mimo jiné) podívat, jak by se výše zmíněné záležitosti zapsaly v programovacím jazyce C#. Nejprve ale stručně k dědičnosti. Řekli jsem si, že Igor (objekt) je člověk (třída). Je jen jeden náš konkrétní Igor, ale je mnoho lidí. Co kdybychom je zúžili? Co kdybychom tvrdili, že Igor je zároveň něco jiného? Pojďme na to:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Igor Novák je student. Existuje jen jeden student? Rozhodně ne. Student tedy bude třída. Studentů může být mnoho. Ne tolik jako lidí, ale stále mnoho.
</p>
</li>
<li>
<p>
Igor Novák je student střední školy. Existuje jen jeden student střední školy? Ne. Student střední školy tedy bude opět třída. Studentů střední školy bude zase o něco mně než studentů obecně, ale pořád se nejedná o unikát.
</p>
</li>
</ol></div>
<div class="olist arabic"><div class="title">Tohle nám ale plodí mnoho, různě sofistikovaných, otázek:</div><ol class="arabic">
<li>
<p>
Nemá student střední školy mnoho společného s jakýmkoliv studentem? (Vskutku ano.)
</p>
</li>
<li>
<p>
Nemá student mnoho společného s jakýmkoliv člověkem? (Opět ano.)
</p>
</li>
</ol></div>
<div class="paragraph"><p>Student střední školy (třída) tedy bude mít mnoho společných vlastností (atributů) a schopností (metod) se studentem obecným. A co mnoho, všechny! Obecný student bude pak mít mnoho společných vlastností a schopností s člověkem (a opět, co mnoho, všechny!). Zde se dostáváme k dědičnosti. Student střední školy dědí (vlastnosti a schopnosti) od studenta obecného. A student obecný dědí totéž od člověka. Obecné? Pojďme to rozklíčovat:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Člověk má věk, výšku a váhu. Každý? Bezpochyby.
</p>
</li>
<li>
<p>
Má student věk, výšku a váhu? Opět bezpochyby. Student to tedy dědí od člověka. Student  má navíc studijní průměr a předměty.
</p>
</li>
<li>
<p>
Má student střední školy studijní průměr a předměty? Ano, opět ano. Každý student střední školy má tyto atributy. Student tedy dědí od obecného studenta. Má ale každý student maturitní zkoušku? Nebo studuje každý student na střední škole? Ne? Pak bychom museli náš model dále upravit.
</p>
</li>
</ol></div>
<div class="imageblock">
<div class="content">
<img src="uml.png" alt="uml.png" />
</div>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Shrňme to. Student střední školy dědí (dědí ve smyslu přejímá stejné členy, čili vlastnosti a metody) od studenta obecného. A student obecný dědí od člověka. Od čeho by mohl dědit člověk? Třeba od savce (každý člověk je savec a má s nimi mnoho společného). S čím pak savec? Se zvířetem. S čím zvíře? S jakoukoliv živou formou. Vidíte? Jsme stále obecnější a obecnější. A proto: není jedna žitá forma (třída), není jedno zvíře (třída), není jeden člověk (zase třída!). Ale je pouze jeden Láďa Novák jakožto unikátní případ studenta.</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="_zapouzdření">Zapouzdření</h3>
<div class="paragraph"><p>Další tajemný pojem. Dotýká se ale vskutku prostých věcí. Zůstaňme u našeho Igora. Víme, jak je vysoký? Víme (nebo snadno zjistíme). Víme, jak se chová? Víme. Dovedeme zjistit jeho reakce na konkrétní situace? Vskutku, Pavlov by mohl povídat, že. Zatím jsme se bavili o tom, jak se nám Igor (objekt, pamatujeme?) jeví navenek. Jaký je ale Igor uvnitř? Zajímá nás to vůbec?</p></div>
<div class="olist arabic"><div class="title">Na tomto místě se opět dostáváme k podstatě věci. Zajímat nás to může, ale nemusí:</div><ol class="arabic">
<li>
<p>
Co když chceme pouze spolupracovat s Igorem (stále objekt) na konkrétním úkolu? Pak nás zajímá, jaký to je pracant, jak se projevuje v rámci kolektivu, jak reaguje. Zajímá nás jeho rozhraní (ano, to je termín z objektového programování pro tento účel).
</p>
</li>
<li>
<p>
Zajímá nás ale jaký je Igor uvnitř? Igor (objekt) je odvozen ze člověka (třída) a jako kterýkoliv jiný, je unikátní. Ale k tomu podstatnému. Zajímá nás to ale? K čemu vědět jak pracují jeho játra? Srdce? Jaký je jeho krevní tlak?
</p>
</li>
</ol></div>
<div class="paragraph"><p>Opět jsme u podstaty věci. U objektového programování nás zajímá, jak se kdo (konkrétní objekt) chová a jaké má vlastnosti. Proč se tak chová a proč má vlastnosti je nám lhostejné. Co když ale sami vytváříme nějaký určitý (ha, ne objekt, ale jeho popis, čili co? Ano, třídu!) Pak musíme přesně určit, proč se co jak chová a jaké je to uvnitř. Jaké vlastnosti a schopnostmi má (třeba člověk, byli-li bychom schopni ho vytvořit, že) skryté uvnitř a <strong>kterými se má naopak projevovat navenek</strong>.</p></div>
<div class="paragraph"><p>To je podstata zapouzdření. Každá třída má vlastnosti a metody (kolonky, vzpomínáte), které jsou  dostupné buď čistě uvnitř ní samotné (pak bychom je nazvali privátní, popř. <code>protected</code>), nebo jímž se na základě třídy vytvořený objekt projevuje navenek, čili o tom, jaké má rozhraní (to bychom se bavili o veřejných, pamatujeme?). Zdůrazněme to znovu, třída (třeba člověk) se navenek nijak projevovat nebude, ale Igor, jakožto instance této třídy (objekt), může být moc zajímavý (mít vlastnosti a metody).</p></div>
<div class="paragraph"><p>Jasné? Pojďme si to zkomplikovat :-)</p></div>
</div>
<div class="sect2">
<h3 id="_co_jsou_to_modifikátory_přístupu">Co jsou to modifikátory přístupu?</h3>
<div class="paragraph"><p>Co označujeme za členy třídy už víte. Zapouzdření znáte také. Každému členu třídy je možné nastavit určité modifikátor přístupu. Zamyslete se nad tím spojením. Modifikujeme přístup. Říkáme, <strong>odkud ke členu dané třídy smí přistoupit</strong> a odkud ne. Běžně se s nimi setkáváte (v C# ani nemůžete jinak), už od  prvního otevření vývojového prostřední vidíte slova jako <code>public</code>, <code>private</code> a mnohá jiná. Nyní se podíváme na ty nejzákladnější ze základních (a zároveň i nejčastěji používaných).</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
K čemu slouží je to <code>private</code>? Použijete ho, když chcete docílit toho, aby dané člen byl dostupný pouze v rámci třídy a dost. Vytvoříte na základě třídy objekt? Ne, člen nebude dostupný navenek. Podědíte ze třídy? Opět smůla.
</p>
</li>
<li>
<p>
Jak je to u <code>protected</code>? Stejně jako v předchozím případě s důležitým rozdílem. Člen bude dostupný ve všech třídách, které ze třídy, kde je umístěn váš člen, dědí. Bude dostupný i navenek? Stále ne, k tomu je třeba další z našeho výčtu.
</p>
</li>
<li>
<p>
Aneb modifikátor přístupu <code>public</code>. Je samopopisný. Je veřejný. Takovýto člen bude poděděn a zároveň bude vidět i navenek na základě třídy vytvořeného objetu. Ano, bude tvořit jeho rozhraní. Přesně v duchu kapitolek o pár řádků výše.
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content">
<pre><code>/* Demonstrace modifikátorů přístupu */

namespace NeskodnyCsharp
{
    class Clovek
    {
        private int ID; // Vlastnost je přístupná pouze ve třídě Clovek
        protected int Vyska;    // Vlastnost je možné zdědit
        public int Vek; // Vlastnost může tvořit rozhraní objektu
    }

    class Student : Clovek
    {
        public Student()
        {
            Vyska = 188;    // Lze přistupovat k poděděné vlastnosti
            /* Inicializace nového objektu na základě třídy Clovek */
            Clovek muz = new Clovek ();
            muz.Vek = 27;   // Přístup k vlasnoti 'Vek' tvořící rozhraní objektu
        }
    }

}</code></pre>
</div></div>
<div class="paragraph"><p>Vždy, když nějaký prvek chcete použít, zamyslete se nad tím, zda ho aktuálně použít můžete. Není-li modifikátor přístupu určen, automaticky se použije <code>private</code>, čili nejpřísnější možná varianta. Pozor na to, je to odlišnost od mnoha jiných jazyků (jako třeba Java), kde mohou být jiné zvyklosti.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Pakliže váháte nad tím, který modifikátor přístupu u vámi vytvářeného členu použít, odpovězte si na otázku: Kde a kdo musí nezbytně tento prvek vidět? Snažte se nastavit tuto úroveň na spíše přísnou než naopak. Snáze opravíte chybu, když někomu (nebo něčemu) dáte oprávnění málo (věřte, on se ozve), než chybu, kdy oprávnění k přístupu byla příliš široká (ten údržbář asi opravdu neměl mít přístup k ovládání reaktoru). Prostě, buďte opatrní (neslyšíte to naposledy).</td>
</tr></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_jaké_známe_druhy_tříd">Jaké známe druhy tříd?</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_popis_jednotlivých_tříd">Popis jednotlivých tříd</h3>
<div class="paragraph"><p>S pojmem třída jsme se tedy už střetli. <strong>Vzor, šablona, popis</strong>. To jsou slova, která udržte v paměti. Budeme je potřebovat. Na řádcích o kousek výše jsme si popsali, jak se třída může chovat. Jednalo se o klasický případ, kdy na základě „vyplnění formuláře“ vytváříme konkrétní objekt. Takovou třídu si můžeme nazvat řekněme „klasickou“. Mnoho o ní ale zatím nevíme.</p></div>
<div class="sect3">
<h4 id="_klasická_třída">Klasická třída</h4>
<div class="paragraph"><p>Obecná, obyčejná, prostě základ, ze kterého vycházíme. Stále rozvíjíme situaci popsanou výše. Pojďme se podívat na to, kde a jak danou třídu definovat, a jak se přiblížit její implementaci v programovacím jazyce C#. Jistě jste si všimli, že když založíme nový projekt, dojde k vytvoření minimálně jednoho souboru, ve kterém se vyskytuje jmenný prostor (<code>namespace</code>), uvnitř něhož je&#8201;&#8212;&#8201;typicky&#8201;&#8212;&#8201;definována jedna třída. Co s tím?</p></div>
<div class="paragraph"><p>Jmenný prostor je oblast, ve které na sebe jednotlivé třídy vidí. Když vytvoříme jmenný prostor <code>Maturita</code> a uvnitř něho třídy <code>Komise</code>, <code>Student</code> a <code>Zkousejici</code> mohou na sebe (bez dalšího) bez problémů vidět. Existovat vedle sebe a čekat než někdo vytvoří jejich instance, čili objekty. Na základně třídy <code>Maturita</code> např. objekt maturita2015, na základě třídy <code>Zkousejici</code> např. <code>kotekDrsnyUcitel</code> a podobně.</p></div>
<div class="olist arabic"><div class="title">Rozveďme si odpověď na otázku, kde třídy definovat:</div><ol class="arabic">
<li>
<p>
Nejčastější situace je, když máme jeden soubor, uvnitř kterého je definována právě jedna třída, která se nachází v rámci jednoho jmenného prostoru. Jsou programovací jazyky, které to ani jiným způsobem neumí a vyžadují právě striktní situaci jedna třída uvnitř jednoho prostoru (a má to svou logiku a smysl z hlediska přehlednosti).
</p>
</li>
<li>
<p>
Druhá možnost je mít uvnitř jednoho souboru v jednom jmenném prostoru více tříd. Typicky je to vhodné v situaci, kdy chceme tyto jednotlivé třídy využít relativně jednoduchým primitivním způsobem. Naopak si představte, že byste měli dvě třídy v jediném souboru a chtěli je souběžně editovat. Vskutku, to není hezká představa skákat  neustále z řádku 353 na řádek 27, není-liž pravda?
</p>
</li>
<li>
<p>
Pak je tu situace třetí. Můžeme mít dva soubory sdílející jeden a ten stejný jmenný prostor, ve kterých je obsažena právě jedna (ano jedna jediná) třída. Bavíme se pak, poměrně logicky, o tzv. částečných&#8201;&#8212;&#8201;partial&#8201;&#8212;&#8201;třídách. I tato situace může mít spoje opodstatnění. Poměrně běžný je případ, kdy v jedné partial třídě je generovaný kód (pokud jste někdy pracovali, a vy jste pracovali, ve Windows Forms, znáte to dobře) a ve druhé kód, kterým pak ručně rozšiřujeme kód ze souboru prvního. Důležité je si uvědomit, že pouze dohromady je vytvořena jedna celistvá třída s jedním názvem.
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content">
<pre><code>/* Demonstrace částečných 'partial' tříd */

namespace NeskodnyCsharp
{
    /**
     * Každá z 'partial' tříd může být v jiném souboru,
     * ale musí být ve stejném namespace
    */

    partial class Clovek
    {
        public int Vek;
    }

    partial class Clovek
    {
        public int Vyska;
    }

    class Program
    {
        public static void Main()
        {
            /* Inicializace nového objektu na základě třídy Clovek */
            Clovek muz = new Clovek();
            /* Lze přistupovat k oběma vlastnostem z obou 'partial' tříd */
            muz.Vek = 27;
            muz.Vyska = 189;
        }
    }
}</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Co si z toho odnést? Předně to, že není jedno správné řešení. Není  žádné dobré versus špatná. Lepší nebo horší. Zahoďte tento způsob uvažování a omezte se na mnohem elegantnější: vhodné a nevhodné. Všechny zmíněné třídy mají své opodstatnění a své využití. Dbejte na to.</td>
</tr></table>
</div>
</div>
<div class="sect3">
<h4 id="_abstraktní_třída">Abstraktní třída</h4>
<div class="paragraph"><p>Je třída, ze které nemůžete (a nechcete) vytvořit její instanci, <strong>nemůžete vytvořit objekt</strong>. Abstraktní třída je úplně neužitečná bez toho, aby z ní někdo (nějaká jiná třída) dědila. Představte si, že máme třídu <code>Firma</code>. V každé firmě budeme chtít počítat platy, třída <code>Firma</code> by tedy měla mít logicky metodu (ano, přesně metodu, podívejme se o pár odstavců výše), která slouží k takovému výpočtu. Něco na způsob VypočtiMzdy (ano, tak by se mohla jmenovat).</p></div>
<div class="paragraph"><p>Položte si teď zásadní otázku: Víte, jak se budou počítat mzdy u každé jednotlivé firmy? Stejně? Sotva. Systém prémií, benefitů (vidíte, jak se to snažím brát optimisticky) bude v různých oblastech dost jiný. Takže pozor. Tvrdíme, že každá firma potřebuje nějak mzdy počítat, ale že těžko nalezneme nějaký jednotící model. A to je ono! O tom jsou abstraktní třídy. Nemůžeme vytvořit objekt na základě třídy <code>Firma</code>, ale můžeme pevně předepsat, že každá třída, která z ní dědí, mzdy počítat musí. Musí obsahovat metodu VypočtiMzdy. Předepišme to tedy. Kde? No právě v abstraktní třídě. Která to je? V tomto případě právě třída <code>Firma</code>. Shrňme to:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Abstraktní třída <code>Firma</code> bude obsahovat deklaraci (opět abstraktní) metody VypočtiMzdy. Pouze deklaraci (fakt, že má existovat), nikoliv definici (jak to má konkrétně počítat). Ještě jednou z této třídy nemůžeme vytvořit její instanci (objekt).
</p>
</li>
<li>
<p>
Třídy (teď již „obyčejné“), které mohou jmenovat např. <code>Automobilka</code> a Reklamní, které budou dědit z Firmy, pak budou muset každá obsahovat jinou definici metody VypočtiMzdy. Muset jako muset. Nebudou-li ji obsahovat, projekt nepůjde zkompilovat. Hotovo. Jak prosté, milý Watsone.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Abstraktní třídy tedy nebyly právě intelektuální výzvou, pojďme na třídy statické :-)</p></div>
</div>
<div class="sect3">
<h4 id="_statická_třída">Statická třída</h4>
<div class="paragraph"><p>Slyšíte to v tom názvu? Statická třída. Neměnná třída. Hotová třída. Ani z této třídy <strong>nevytváříme objekty</strong>, a ani u této třídy to hlavně dělat nechceme. Měli jste někdy potřebu vypsat nějaká data do konzole v přesně definovaném formátu? Nebo vícenásobně použít nějakou funkci, kterou jste někde definovali? Tady jsme u toho. Opět si položte otázku: Má smysl, abyste definovali např. Metodu <code>VypisVeSloupcich</code> v deseti různých třídách? Asi řeknete ne, ale vyvstává tu logická námitka: Proč nemohu tuto metodu definovat ve třídě, ze které ostatní dědí?</p></div>
<div class="paragraph"><p>Toto je zásadní moment. Proč ne? Vždyť to má svou logiku. Uvědomme si následující. Pokud mezi sebou třídy dědí, znamená to, že mezi sebou mají vztah, logickou návaznost, propojenost vztahu od obecného ke konkrétnímu. Od třídy <code>Firma</code> může dědit třída <code>Automobilka</code>, od třídy <code>Automobilka</code> třída <code>CeskaAutomobilka</code>. V pořádku? Dobrá. Asi se shodneme, že každá z těchto tříd by mohla chtít umět vypsat nějaká data ve sloupcích. Stále v pořádku? OK. Znamená to ale, že třída Pračka dědící ze třídy <code>Vyrobek</code>, žádná taková data k vypsání nemá? Aha, jsme u toho.</p></div>
<div class="olist arabic"><div class="title">Problém je následující:</div><ol class="arabic">
<li>
<p>
Metoda <code>VypisVeSloupcich</code>, která by bylo obsažená ve třídách <code>Firma</code> a <code>Vyrobek</code>, by dělala přesně to samé, přesně ve stejných situacích. Pracovala by přesně se stejnými vstupními daty. Byla by stejná. Opakování, opakování, opakování. To je přesně to co nechceme. Pamatujme na to, vždy, když narazíme na opakování, má nám to značit, že je něco špatně (a bohužel dost typicky a pravděpodobně na naší straně, to jest hoře programátorovo).
</p>
</li>
<li>
<p>
Správný postup je, jak název kapitolky napovídá, použít statickou třídu. Statická třída obsahuje výčet obecně použitelných metod nebo konstant, které chceme použít nezávisle na dalším. Naše statická třída by se tedy mohla jmenovat např. Výstup a metoda <code>VypisVeSloupcich</code> by jako argument mohla přebírat data jakékoliv jiné třídy, které by bylo potřeba v nějaký okamžik vypsat.
</p>
</li>
</ol></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Statická třída je tedy o výčtu. O znovupoužitelnosti. O použitelnosti nezávisle na určitých datech. Vypadá tajemně, ale není. Znáte třídu Math? (měli byste), obsahuje metody pro výpočet sinu a konstanty jako je PI. Zkoušeli jste si někdy vytvořit instanci třídy Math? Asi tušíte kam směřuji, nešlo by to, je statická. Vztahuje se výpočet sinu a PI ke konkrétní oblasti? (Hmm, možná tak k matematice.) Ale jistě oba prvky použijeme v mnoha jiných situacích (konstrukce, analytická geometrie, energetika), až v desítkách či stovkách. Ne v jedné oblasti. Řekli jsme mnoho a vychází nám jasný to kandidát na statickou třídu.</td>
</tr></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_klíčové_pojmy_k_třídám">Klíčové pojmy k třídám</h3>
<div class="sect3">
<h4 id="_konstruktor">Konstruktor</h4>
<div class="paragraph"><p>Zatím jsme se drželi jen u těch nejzákladnějších termínů, pojďme se podívat na některé lehce specifičtější. Co je to konstruktor? Existuje na to extrémně stručná odpověď: metoda. Konstruktor je nicméně <strong>metoda, která je velmi specifická</strong> a to následujícími věcmi:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Jmenuje se stejně jako třída, ve které je obsažena. Třída <code>Skola</code>, tedy bude obsahovat konstruktor s název <code>Skola()</code>.
</p>
</li>
<li>
<p>
Nemá žádný návratový typ. U obyčejné metody musíme určit minimálně to, že metoda žádnou hodnotu nevrací (použijeme pak klíčové slovo void). U konstruktoru ne.
</p>
</li>
<li>
<p>
Je volána v okamžiku, kdy vytváříme konkrétní instanci třídy. Ano píšeme-li <code>Skola ssps = new Skola()</code>, pak výraz <code>Skola()</code> je konstruktorem této třídy.
</p>
</li>
</ol></div>
<div class="paragraph"><p>K čemu je nám v praxi konstruktor dobrý? Znovu se vraťme k tomu, k čemu je nám třída. Je to prázdný formulář, který chceme vyplnit. Klíčové je kdy. Pokud bychom vytvořili objekt podle příkladu výše (v bodu 3), pak je to sice formulář s razítkem, ale stále poněkud smutně prázdný. Objekt existuje, ale je takový lejaký nijaký. Co s tím?</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Můžeme postupně přistoupit k veřejně přístupným (tedy <code>public</code>) vlastnostem objektu (tvoří rozhraní tohoto objektu, pamatujeme?) a postupně určit, že <code>ssps</code> má takovéhoto ředitele, takovéto studenty apod. To jest cesta první.
</p>
</li>
<li>
<p>
Nebo můžeme tyto údaje předat přímo konstruktoru jako argumenty. V okamžiku, kdy někdo vytváří objekt na základě třídy škola, je tímto donucen, aby alespoň minimální množství argumentů předal.
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content">
<pre><code>/* Jak lze použít konstruktor */

namespace NeskodnyCsharp
{
    class Skola
    {
        /* Třídní proměnné Nazev a Adresa */
        public string Nazev;
        public string Adresa;

        /* Konstruktor třídy a jeho typické použití */
        public Skola(string naz, string adr)
        {
            /**
             * Přiřazení výchozích hodnot do třídních proměnných
             * pomocí přiřazení v konstruktoru
            */
            Nazev = naz;
            Adresa = adr;
        }
    }

    class Program
    {
        public static void Main()
        {
            /**
             * Vytvoření nového objektu 's' dle konstruktoru Skola()
             * třídy Skola s jeho argumenty
            */
            Skola s = new Skola("SPS", "Adresa 25, Praha");
        }
    }
}</code></pre>
</div></div>
<div class="paragraph"><p>Protože programování není o uctívání svatých krav, můžeme tak oba přístupy kombinovat, třeba použít konstruktorů více s různými požadovanými argumenty, pak se bavíme o přetěžování konstruktoru. (Chcete vědět víc? Podívejte se na kapitolu „Proč přetěžovat metody“.) Můžeme tak klidně definovat konstruktor, který nepřebírá žádný argument; který přebírá argument jeden, nebo další, který jich přejímá více. Co když ve třídě žádný konstruktor nepoužijeme? Je to prosté, pak se použije implicitní konstruktor, který nevidíme, ale je tam. Byl, je a bude.</p></div>
</div>
<div class="sect3">
<h4 id="_slůvka_this_a_base">Slůvka „this“ a „base“</h4>
<div class="paragraph"><p>Co znamenají? Je dost pravděpodobné, že jste se s nimi někde v rámci tvořeného zdrojového kódu setkali. Neskrývá se za nimi nic tajemného. Běžně v rámci nějaké třídy voláme její člen (pamatujeme, co člen znamená?). Nejčastěji ho voláme čistě jeho názvem (a v C# není zvlášť mnoho situací, které by nás nutili k tomu dělat to jinak). Vrátíme-li se k naší třídě <code>Clovek</code> vidíme, že jsme pracovali s členem (tady atributem) značícím výšku (nazvěme ho tedy <code>Vyska</code>). Můžeme ho v rámci třídy volat jednoduše, tedy pouze <code>Vyska</code>, jako by to byla jakákoliv jiná proměnná. Stejně tak dobře ale můžeme napsat <code>this.Vyska</code>. Proč je tomu tak?</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Slovo <code>this</code> nám ukazuje na konkrétní instanci třídy, tedy objekt. Můžeme mít mnoho různých instancí třídy <code>Clovek</code> (Igora, Honzu, kohokoliv) a každá z nich v sobě bude obsahovat vlastnost <code>Vyska</code>. Zápisem <code>this.Vyska</code> říkáme, že se vztahujeme právě k tomuto konkrétnímu člověku a atributem <code>Vyska</code> k hodnotě poplatné právě a jen tomuto člověku.
</p>
</li>
<li>
<p>
Můžeme si to demonstrovat ještě jinak. Program, který není spuštěný, leží na pevném disku. V okamžiku, kdy ho spustíme, se stane procesem a získá svá specifika (přidělenou operační paměť, prioritu procesu) včetně konkrétních hodnot jeho atributů. V čem je klíčový fígl? Daný program můžete spustit vícekrát, jedná se tedy o více spuštěných instancí (a slůvko <code>this</code> se vztahuje ke každému jednotlivému z nich).
</p>
</li>
</ol></div>
<div class="paragraph"><p>Jak byl popis slůvka <code>this</code> vyčerpávající, popis slůvka <code>base</code> bude o to kratší. Týká se dědičnosti. V C# máme vždycky maximálně jednu třídu, ze které dědíme, ne více. A pojem <code>base</code> se vztahuje právě k ní. Může nastat situace, kdy budeme potřebovat sáhnout na nějaký člen obsažený v takové třídě, přesně k tomu se <code>base</code> hodí. Ostatně to je přesně ten důvod, proč takové třídě říkáme bázová.</p></div>
<div class="olist arabic"><div class="title">Pojďme si možné situace shrnout a ilustrovat na příkladu:</div><ol class="arabic">
<li>
<p>
Třída <code>Student</code> dědí ze třídy <code>Clovek</code>. Uvěřitelný předpoklad. Budu-li si chtít sáhnout v rámci kódu ve třídě <code>Student</code> na atribut <code>Vyska</code> ve tvaru, ve kterém je obsažený ve třídě <code>Clovek</code>, napíšu poměrně přímočaře <code>base.Vyska</code>. Lehké, že?
</p>
</li>
<li>
<p>
Vaše úplně logická otázka je, proč bychom něco takového vůbec měli dělat? Vždyť jsme obsah třídy <code>Clovek</code> podědili (ano, máme-li nastavené modifikátory přístupu minimálně na <code>protected</code>). Máte pravdu. Vtip je v tom, že ne vždy chceme v aktuální třídě použít poděděný člen přesně v takovém tvaru, ale chceme pracovat s oběma.
</p>
</li>
<li>
<p>
Zmatečné? Možná to tak na první pohled vypadá, ale všechno bude křišťálově čisté hned, jak se dostane k další kapitole o polymorfismu. Proteď si zapamatujme, že s <code>base</code> se asi nejčastěji v C# setkáme, když chceme přebrat ze třídy, ze které dědíme konstruktor a třeba ho mírně doplnit a rozšířit. Tajemné? Není, podívejte se na příklad níže.
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content">
<pre><code>/* Jak prakticky využít 'base' a 'this' */

namespace NeskodnyCsharp
{
    class Clovek
    {
        public int Vyska;

        public Clovek(int vys)
        {
            /* Oba dva zápisy dělají naprosto totéž */
            this.Vyska = vys;
            Vyska = vys;    // Zkrácený tvar přiřazení
        }
    }

    class Student : Clovek
    {
        public string Skola;

        /**
         * Podědění bázového konstruktoru a jeho rozšíření
         * o další argument - určení školy
        */
        public Student(int vys, string sko) : base(vys)
        {
            Skola = sko;    // Opět, lze zapsat i jako this.Skola = sko;
        }
    }
}</code></pre>
</div></div>
<div class="paragraph"><p>Vidíte, že na tom nic není. Námi nově vytvořený konstruktor (ve třídě <code>Student</code>) zbytečně <strong>neopakuje, co už dělá konstruktor v bázové třídě</strong> <code>Clovek</code> (to slůvko si pamatujme) . Přebírá argumenty poplatné bázovému konstruktoru a předává mu je, zatímco sám nově vyžaduje pouze nový argument <code>skola</code>, který předává do třídní proměnné <code>Skola</code>. Pouze a jen to, žádný zbytečný kód navíc. (A co si budeme říkat, pouze a jedině tam má smysl. Chodí snad každý člověk stále do školy?)</p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_k_čemu_slouží_a_co_je_to_polymorfismus">K čemu slouží a co je to polymorfismus?</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_proč_přetěžovat_metody">Proč přetěžovat metody</h3>
<div class="paragraph"><p>Protože chceme pro metody používat hezké a dobře <strong>zapamatovatelné názvy</strong>. A spolu s tím – protože naopak nechceme používat mnoho podobných (a lehce zaměnitelných) názvů. To je podstatou. Z čeho ale vyplývá taková potřeba? Můžeme chtít mít v našem programu metody, které dělají principiálně totéž, ale přebírají různý počet argumentů. Jak by to tedy mohlo vypadat?</p></div>
<div class="olist arabic"><div class="title">Pojďme přijít na nějaký příklad:</div><ol class="arabic">
<li>
<p>
Metoda, která vypisuje počet sekund na základě vstupních dat, by se mohla nazývat, řekněme <code>VypisSekundy</code>. Co by taková metoda mohla přebírat na vstupu jako argument? Dny? Hodiny? Minuty? Dny a hodiny? Dny, hodiny a minuty?
</p>
</li>
<li>
<p>
Pro každou z těchto situací bycho dovedli vymyslet hezký název. Něco a la <code>VypisSekundyNaZakladeHodin</code>, <code>VypisSekundyNaZakladeHodinMinut</code>. Už teď si je nepamatujete, že? Přitom původní název <code>VypisSekundy</code> je zapamatovatelný dokonale. A tady nastupuje přetěžování, my tento název vícenásobně použít opravdu můžeme.
</p>
</li>
<li>
<p>
Pozor, <strong>přetěžování není všespásné</strong>. Použijeme ho, když máme různý počet argumentů, nebo když máme argumenty jiného typu. Kdybychom chtěli přetížit název metody <code>VypisSekundy</code> a na vstupu předávat jako jeden argument v prvním případě počet minut (jako celé číslo), ve druhém pak počet hodin (zase jako celé číslo), máme smůlu.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Chtěl jsem napsat dlouhý vysvětlující odstavec, ale podívejte se o pár odstavců níže. Není tam uvedený kód jasný? Máme hezké zapamatovatelné názvy metod? Máme. Mají metody různý počet argumentů? Opět ano. Takže jsme právě viděli podstatu přetěžování. A o tom to je.</p></div>
</div>
<div class="sect2">
<h3 id="_kdy_použít_překrývání">Kdy použít překrývání</h3>
<div class="paragraph"><p>Všimněte si, že doteď jsme se pohybovali pouze v rámci jedné třídy. Všechny přetížené metody tam byly obsaženy hezky pěkně pod sebou. Tak to ale být nemusí. Je úplně běžná situace, že chceme nějakou metodu podědit, ale použít jinak. (A ano tohle je přesně to místo, které by vás mělo začít zajímat po odskoku od nyní už známého slůvka <code>base</code>.) Může to být libovolná metoda včetně klidně včetně konstruktoru.</p></div>
<div class="olist arabic"><div class="title">Klasikou v tomhle směru je v C# metoda na převod čehokoliv na řetězec:</div><ol class="arabic">
<li>
<p>
Aneb <code>ToString</code>. Naleznete ji u jakéhokoliv objektu, takže u všeho. Proč? Její definice je obsažena ve třídě Object a z této třídy dědí doslova všechny další třídy. Všechny. Na počátku je vždy ona. Chová se ale metoda <code>ToString</code> stejně u objektu typu <code>Int32</code> i u, řekněme objektu typu <code>Button</code>?
</p>
</li>
<li>
<p>
Odpověď asi tušíte. Ne, chovají se jinak. Jak převést číslo na řetězec? Jednoduché. Ale tlačítko na řetězec? Uff, to už vypadá na netriviální problém. Logicky tedy dospějeme k tomu, že jak ve třídě <code>Int32</code>, tak <code>Button</code>, bude mít metoda <code>ToString</code> mít svou definici, ale ta bude v každé třídě jiná. Jiná i když obě dědí ze třídy Object. A zde nastupuje překrývání.
</p>
</li>
</ol></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Kdy tedy překrývání použít? Vždy, když chceme použít nějaký název znovu v rámci hierarchie dědičnosti. A z dobrého důvodu. Používejme tuto možnost vždy, když víme co děláme, jinak se stane zbraní hromadného ničení. (Ale lze celkem úspěšně předpokládat, že taková raketa typu Trident bude programována spíše Adě než v C#.) Pohybujeme se tedy po dědičnosti, vertikálně. Horizontální pohyb by zde byl čím? Správně, přetěžováním.</td>
</tr></table>
</div>
<div class="sect3">
<h4 id="_virtuální_a_abstraktní_metody">Virtuální a abstraktní metody</h4>
<div class="paragraph"><p>Máme tedy bázovou třídu, ze které dědíme. V té máme metodu, jejíž název chceme dále – ve třídě, která z ní bude dědit – použít. Tyto metody chceme nějak označit, dát najevo, že mohou (nebo musí) být ve třídě z bázové dědící předefinovány (nebo definovány). Použijeme pro to dvě klíčová slůvka a to <code>virtual</code> a <code>abstract</code>. Bavíme se pak o virtuální a abstraktní metodě. Povědomé? Přesně, už jsme se o tom bavili v kapitolce o abstraktních třídách a toto povídání na ni přesně navazuje.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<strong>Virtuální metoda</strong> je metoda, u které dáváme najevo, že může, ale nemusí, být překryta. Dáváme, sami sobě, nebo jinému programátorovi, najevo, že ze scénářem, že překrytí takovéto metody se prostě počítá.
</p>
</li>
<li>
<p>
<strong>Abstraktní metodu</strong> bychom už měli znát. Ta nejenom, že může. Ne, ta musí být definována. V bázové třídě je obsažen pouze popis, že má existovat metoda s určitým názvem a přebírat nějaké argumenty. Je deklarovaná. Její definice ale musí přijít až ve třídě, která z ní podědí.
</p>
</li>
</ol></div>
<div class="olist arabic"><div class="title">Asi vás napadnou dva možné scénáře:</div><ol class="arabic">
<li>
<p>
Co když slůvko <code>virtual</code> neuvedu? Moderní kompilátory do bytecode (nebo přesněji do CIL) vám to pravděpodobně povolí a funkčnost bude opticky identická, nicméně nedělejme to. Je to příklad benevolence, který se nemusí vždy vyplatit.
</p>
</li>
<li>
<p>
Co když metodu, která je uvedena jako abstraktní, nedefinuji? Tady to je prosté. Váš kód nepůjde zkompilovat. Hotovo. Chybové hlášení, které to popisuje, je ale velmi přesné. Nemusíte se bát. Uvidíte a opravíte.
</p>
</li>
</ol></div>
</div>
<div class="sect3">
<h4 id="_logika_klíčových_slov_override_a_new">Logika klíčových slov override a new</h4>
<div class="paragraph"><p>Zatím jsme se pohybovali na úrovni definic (nebo deklarací) metod, které můžeme (nebo musíme) překrýt. Jak je to ale na druhé straně? U tříd, které z nich dědí? Stejně tak, jako dáváme najevo, že povolujeme překrytí metody, musíme dát najevo, že danou metodu překrýváme (nebo definujeme). I tady máme klíčová slova, nyní v podobě pojmů <code>new</code> a <code>override</code>. Jak na ně?</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Použijeme-li klíčové slovo <code>override</code>, říkáme, že metoda, kterou právě chceme napsat bude zachovávat logiku té, kterou překrýváme. Neměníme <strong>její smysl</strong>. Neměníme její <strong>návratový typ</strong>. <code>ToString</code> by vždy měl převádět něco na řetězec. Ne vždy to ale bude dělat tím jedním správným možným způsobem. Proto překrýváme. To dává smysl, že?
</p>
</li>
<li>
<p>
A co když je to „nové“? Kdy použít <code>new</code>? To je vzácnější situace. Někdy můžeme chtít použít už existující název metody pro zcela novou věc. Ve zcela nové situaci. Pro metodu, která se <strong>liší od oné překrývané smyslem i návratovým typem</strong>. Představte si, že by metoda <code>ToString</code> vracela celé číslo, které by odpovídalo nějakému matematickému výpočtu. To by nedávalo smysl, že? Dobře si rozmyslete, jestli něco takového chcete udělat.
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content">
<pre><code>/* Demonstrace překrývání a přetěžování */

using System;

namespace NeskodnyCsharp
{
    class Clovek
    {
        public int Vyska;

        /* Virtuální metoda, kterou je možné přerýt */
        public virtual string VypisUdaje()
        {
            return Vyska.ToString ();
        }
    }

    class Student : Clovek
    {
        public string Skola;

        /* Metoda, která překrývá bázovou metodu 'VypisUdaje' */
        public override string VypisUdaje ()
        {
            return String.Format ("{0} {1}", Vyska, Skola);
        }

        /* Metoda, která přetěžuje metodu 'VypisUdaje' - má jiný počet argumentů */
        public override string VypisUdaje (bool vsechno)
        {
            if (vsechno)
            {
                return String.Format ("{0}, {1}", Vyska, Skola);
            }
            else
            {
                return Skola;
            }
        }
    }
}</code></pre>
</div></div>
<div class="paragraph"><p>A opět si rozebereme příklad. Pozorně se podívejte na komentáře, které jsou v něm obsažené. Překrývání nám obecně může ušetřit mnoho práce, může usnadnit a zpřehlednit náš kód už tím, že v něm budou použity komukoliv známé názvy metod, které budou dělat správně to, co se od nich běžně očekává. Ale ještě jednou zopakuji. Opatrně, používejte překrývání, když má smysl.</p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_jak_se_pracuje_s_rozhraními">Jak se pracuje s rozhraními?</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_význam_rozhraní">Význam rozhraní</h3>
<div class="paragraph"><p>Aneb mikrokapitola na závěr. S pojmem rozhraní jsme se už setkali. Můžeme ho použít v obecném smyslu, tak jsme o něm mluvili. Objekt má nějaké rozhraní. Klasika. V programovacím jazyce C# však ale máme ještě další nástroj pro to, jak s rozhraními pracovat. Jakýsi předpis, který nám říká, že musíme v dané třídě implementovat konkrétní metody. Tento předpis se nazývá interface, čili do češtiny přeloženo: rozhraní. Jestli vám to připomíná pojetí abstraktních tříd je to zcela správná úvaha, nicméně rozhraní nejsou přesnou analogií. Proč tomu tak je?</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Vzpomeňte si, že v C# můžete <strong>dědit pouze a výhradně z jedné třídy</strong>. Tečka. Včetně abstraktních tříd. To je velmi omezující. Chtěli byste podědit z naší známé třídy <code>Clovek</code> a zároveň z abstraktní třídy <code>Chovani</code>? Smůla, jakkoliv by to mělo svou logiku.
</p>
</li>
<li>
<p>
Rozhraní nicméně můžeme <strong>implementovat tolik, kolik chceme</strong>. Kdyby naše třída měla dědit ze třídy <code>Clovek</code> a implementovat rozhraní <code>Chovani</code>, šlo by to? Bez potíží. A klidně by mohla pokračovat implementováním dalších rozhraní. A u člověka si lze představit mnoho předpisů, které každý jednotlivec musí splnit, že?
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content">
<pre><code>/* Demonstrace použití rozhraní */

using System;

namespace NeskodnyCsharp
{
    interface Chovani
    {
        /* Sada metod, které musí být implementovány */
        void Mluvit ();
        void Myslet ();
    }

    class Clovek
    {
        public string Jmeno;
    }

    /**
     * Třída 'Student' dědí ze třídy člověk a zároveň implementuje
     * předepsané rozhraní 'Chovani'
    */
    class Student : Clovek, Chovani
    {
        /* Nezbytné definice předepsaných metod */
        public void Mluvit()
        {
            Console.WriteLine (Jmeno + ": Mluvím!");
        }

        public void Myslet()
        {
            Console.WriteLine (Jmeno + ": Myslím!");
        }
    }
}</code></pre>
</div></div>
<div class="paragraph"><p>Příklad výše nám tedy jasně ukazuje, o čem rozhraní jsou. Bylo nařízeno implementovat určitou sadu metod? Bylo. Podařilo se tyto metody implementovat? Podařilo. Pak gratuluji, dostali jste se k závěru našeho povídání.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_závěr">Závěr</h2>
<div class="sectionbody">
<div class="paragraph"><p>Snad (ne)škodný úvod do pojetí objektového programování v prostředí programovacího jazyka C# máte nyní za sebou. Ale to by neměl být konec. Zpochybňujte. Dohledávejte další zdroje. Hledejte změny. Porovnávejte se situací v jiných jazycích. Ne všechny programovací jazyky mají svůj objektový model založený na třídách (podívejte se na Javascript a jeho pojetí OOP přes prototypy), ne všechny jazyky mají rozhraní a zakazujíc vícenásobnou dědičnost (Python). Ne všechny jazyky znají modifikátory přístupu (opět je jich mnoho). A šlo by pokračovat.</p></div>
<div class="paragraph"><p>V době, kdy tento text čtete, už může být vývoj objektového programování (a zdaleka nejen toho) na místě, který byste vy a já nečekali. A proto Shrnu v jedné větě: <strong>Nebuďte statičtí</strong>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_zdroje">Zdroje</h2>
<div class="sectionbody">
<div style="page-break-after:always"></div>
<div class="paragraph"><p>&#169; Lukáš Kotek 2015, <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA 4.0</a></p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2015-11-21 14:24:01 CET
</div>
</div>
</body>
</html>
