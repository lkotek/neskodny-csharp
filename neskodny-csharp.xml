<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>(Ne)škodný úvod do OOP v jazyce C#</title>
<date>2015-12-01</date>
</info>
<preface>
<title></title>
<simpara>Lukáš Kotek &lt;<link xlink:href="mailto:lukaskotek@gmail.com">lukaskotek@gmail.com</link>&gt;</simpara>
<tip>
<simpara>Tento dokument nemá ambici v žádném slova smyslu suplovat technickou dokumentaci, odborné publikace nebo učebnice, které se zabývají programováním a programovacím jazykem C#. Rovněž není jeho cílem poskytovat dokonale exaktní formulace a definice pojmů ze zmíněné oblasti. Naopak cílí na uživatele (a zde konkrétně na studenty středních škol), kteří do objektového programování zatím pouze jemně vplouvají a potřebují proto nenásilnou formou osvětlit základní pojmy a principy, které s&#160;objektovým programováním souvisí. Prosím nazírejte na něj s vědomím výše zmíněného.</simpara>
</tip>
<simpara><?asciidoc-pagebreak?></simpara>
</preface>
<chapter xml:id="_co_je_to_objektově_orientované_programování">
<title>Co je to objektově orientované programování</title>
<section xml:id="_proč_použít_objektové_programování">
<title>Proč použít objektové programování</title>
<simpara>Objektově orientované programování (OOP) je o zcela <emphasis role="strong">jiném přístupu k programování</emphasis>, než který dříve byl (a samozřejmě i v mnoha případech a z dobrého důvodu dosud je) používán. Jakým způsobem jsme se dívali na program dříve? Jako na sled po sobě jdoucích pokynů. Čili:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Krok první: udělej to (třeba načti hodnotu do proměnné);</simpara>
</listitem>
<listitem>
<simpara>Krok druhý: udělej ono (umocni prve načtenou proměnnou na druhou);</simpara>
</listitem>
<listitem>
<simpara>Krok třetí: pokud platí A, proveď B (pokud je číslo nenulové, použij ho jako dělitel).</simpara>
</listitem>
<listitem>
<simpara>Následující krok: &#8230;&#8203;</simpara>
</listitem>
</orderedlist>
<simpara><emphasis>A podobně bychom mohli pokračovat, je to zjevné?</emphasis></simpara>
<simpara>Algoritmus jsme popsali vývojovým diagramem, který pro nás byl přesným návodem pro to, co kdy a jak udělat. Program pak pro nás pak byl <emphasis role="strong">strukturovaným přepisem tohoto návodu</emphasis> do konkrétního programovacího jazyka (s jemu poplatnými příkazy a specifickou syntaxí).</simpara>
<simpara>Pojďme se podívat na objektově orientované programování (je to dlouhý pojem, pojďme si vystačit se zkratkou OOP, platí?). Předně, OOP vůbec neříká, že to, co je v prvním odstavci není pravda. Algoritmus bude vždy posloupností kroků. OOP říká, že se mění náš pohled na program jako takový. Hlavní pro nás už není postup řešení (aneb co a jak jde za sebou), ale <emphasis role="strong">to s čím vlastně pracujeme</emphasis> (a o co se vlastně jedná, z čeho se to skládá, jak se to chová, jak to popíšeme?).</simpara>
<note>
<simpara>Všimli jste si tajemného „ono“? To ono, tajemná věc, o které mluvíme, se nazývá objekt.</simpara>
</note>
</section>
<section xml:id="_něco_teorie_k_základní_terminologii">
<title>Něco teorie k základní terminologii</title>
<section xml:id="_objekt">
<title>Objekt</title>
<simpara>Máme tu tedy tajemný pojem objekt. Ale on vlastně vůbec není tajemný. Objekt je prvek, kterým se snažíme popsat něco z reálného světa. Co nás napadá? Vezměme těžkou klasiku. Člověka, ale ne ledajakého člověka, vezměme <emphasis role="strong">konkrétního člověka</emphasis>, spolužáka, kamaráda, např. Igora Nováka (budeme jeho služeb v průběhu textu využívat i dále). Co bychom o něm mohli říct? Třeba, že je nějak vysoký, umí nějaké věci; dá se čekat, že když spadne ze schodů, bude na to nějak reagovat.</simpara>
<orderedlist numeration="arabic">
<title>Všimněte si toho hlavního:</title>
<listitem>
<simpara>Nás nezajímá jen tak ledajaký člověk (těch je spousta), nás zajímá Igor Novák s&#160;konkrétními vlastnostmi, schopnosti a dovednostmi. Mohli bychom univerzálně popsat obecného člověka s&#160;přesně definovanými vlastnostmi a schopnostmi? Sotva, každý je něčím specifický. Ale Igor Novák? Ten je náš jeden konkrétní objekt.</simpara>
</listitem>
<listitem>
<simpara>Nás nezajímají jen samotné údaje tohoto člověka. Nás nezajímá čistě hodnota cholesterolu, ani výška, ani váha. Ne. Pro nás je zásadní, že je to Igorova hodnota cholesterolu, Igorova výška a Igorova váha. Nejsou to samostatně stojící prvky, pevně se váží k&#160;Igorovi, popisují ho, jsou s ním spjaté. Igor je objekt, je jedinečný.</simpara>
</listitem>
</orderedlist>
<simpara>Jeli-to jasné, pojďme se posunout o kousek dále, k zásadnímu pojmu třída.</simpara>
</section>
<section xml:id="_třída">
<title>Třída</title>
<simpara>Už jsme si řekli, že <emphasis role="strong">Igor je objekt</emphasis>. Že Igor je jedinečný. Ale je tak jedinečný, že bychom ho nemohli k&#160;někomu připodobnit? Co o&#160;něm víme? Že Igor je také člověk. Jako já, jako vy. Všcihni máme mnoho společných vlastností. Všichni jsme nějak vysocí, všichni máme nějakou váhu, hodnotu cholesterolu, každý umíme mluvit, ale mluvíme všichni stejně? Rozhodně ne. Co z&#160;toho plyne:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Existuje mnoho lidí. Jsou různí, ale mohou mít společné vlastnosti;</simpara>
</listitem>
<listitem>
<simpara>Každý jsme vytvořený podle společného vzoru, každý máme DNA, ale nikdo stejnou.</simpara>
</listitem>
</orderedlist>
<simpara>Všichni známe DNA, platí? Kdo ne, dohledá si na (něco)pedii. Představme si, že je to šablona, podle které jsou vytvářeni konkrétní lidé. Smícháním určitých genů vznikne určitý člověk. Ještě jednou: je mnoho lidí, ale Igor Novák je jen jeden. Všichni lidé jsou ale vytvořeni podle společného vzoru, podle společné šablony. Tím se dostáváme k jádru věci.</simpara>
<simpara>Vzor? Šablona? Pojďme použít lepší termín: <emphasis role="strong">třída</emphasis>. Třída je papír, na kterém je napsáno, že každý člověk má být nějak vysoký, má mít nějaký věk, má mít nějaké schopnosti. Jakou výšku? Jaký věk? Jaké schopnosti? To třída netuší. Je to opravdu jen šablona. Jeto prázdný formulář. Má kolonky, ale ty kolonky nejsou vyplněné. Až když je vyplníme, vznikne konkrétní člověk. Vznikne náš Igor.</simpara>
<orderedlist numeration="arabic">
<title>Tohle je zásadní moment. Tvrdíme, že:</title>
<listitem>
<simpara>Igor je objekt (to už jsme tvrdili dříve, že?);</simpara>
</listitem>
<listitem>
<simpara>Že Igor je člověk, který je vytvořený podle šablony, vzoru, formuláře „člověk“.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>Igor je tedy unikátním a neopakovatelným případem člověka. Vyplnili jsme formulář člověk a vznikl Igor. Vyplnili bychom ho jinak a vznikl by Pepa, ještě jinak a měli bychom tu Janu, úplně jinak a měli bychom tu Jamese T.&#160;Kirka. Igor je tedy instancí třídy člověk. Co je instance třídy? Je to vyplněný formulář, je to objekt. Objekt je tedy pojem totožný s&#160;instanci třídy.</simpara>
</note>
</section>
<section xml:id="_Člen_třídy">
<title>Člen třídy</title>
<simpara>Tahle pasáž bude stručná. Už víme, kdo je to Igor. Už víme, co je to člověk. Člen třídy nám vypovídá o&#160;tom, o&#160;jakého člověka se jedná. Je-li člověk formulář, pak člen třídy je konkrétní položkou.</simpara>
<orderedlist numeration="arabic">
<title>Členové třídy, ale mohou být velice různí:</title>
<listitem>
<simpara>Mohou říkat, že člověk má mít nějakou výšku, věk či barvu očí;</simpara>
</listitem>
<listitem>
<simpara>Mohou říkat, že člověk může nějak měnit svůj stav, že člověk nějak koná;</simpara>
</listitem>
<listitem>
<simpara>Mohou říkat, že člověk může nějak reagovat na nějaké události.</simpara>
</listitem>
</orderedlist>
<simpara>Pojďme krok za krokem. První případ nazýváme <emphasis role="strong">vlastností, nebo atributem</emphasis> (popisujeme, jaký –- a pozor zase se jedná až o konkrétního jedince –- člověk je). Igor má modré oči. Druhý případ nazýváme <emphasis role="strong">metodou</emphasis> (popisujeme, jak se daný člověk projevuje). A zase: každý člověk umí hubnout, ale pouze Igor umí hubnout o&#160;5 kg za půl roku. A reakce na události? Představte si, že vás někdo udeří. Každý člověk na to bude reagovat, ale pouze Igor uteče rychlostí 20 km/h směrem na severovýchod za hlasitých výkřiků. Zde jsme se dotkli pojmu <emphasis role="strong">událost</emphasis> (specifický případ vlastnosti).</simpara>
</section>
</section>
<section xml:id="_dědičnost_mezi_třídami">
<title>Dědičnost mezi třídami</title>
<simpara>Dosud jsme se pohybovali na výrazně abstraktní rovině. Pojďme se tedy (mimo jiné) podívat, jak by se výše zmíněné záležitosti zapsaly v programovacím jazyce C#. Nejprve ale stručně k&#160;dědičnosti. Řekli jsem si, že Igor (objekt) je člověk (třída). Je jen jeden náš konkrétní Igor, ale je mnoho lidí. Co ale kdybychom je (myšlené lidi) mírně zúžili? A co kdybychom tvrdili, že Igor má přeci jen s&#160;nimi něco společného? Pojďme na to:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Igor Novák je student. Existuje jen jeden student? Rozhodně ne. Student tedy bude třída. Studentů může být mnoho. Ne tolik jako lidí, ale stále mnoho.</simpara>
</listitem>
<listitem>
<simpara>Igor Novák je student střední školy. Existuje jen jeden student střední školy? Ne. Student střední školy tedy bude opět třída. Studentů střední školy bude zase o&#160;něco méně než studentů obecně, ale pořád se nejedná o&#160;žádné unikáty.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Tohle nám ale plodí mnoho, různě sofistikovaných, otázek:</title>
<listitem>
<simpara>Nemá student střední školy mnoho společného s&#160;jakýmkoliv studentem? (Vskutku ano.)</simpara>
</listitem>
<listitem>
<simpara>Nemá student mnoho společného s&#160;jakýmkoliv člověkem? (Opět ano.)</simpara>
</listitem>
</orderedlist>
<simpara>Student střední školy (třída) tedy bude mít mnoho společných vlastností (atributů) a schopností (metod) se studentem obecným. A co mnoho, všechny! Obecný student bude pak mít mnoho společných vlastností a schopností se člověkem (a opět nejen mnoho, ale všechny!). Zde se dostáváme k <emphasis role="strong">dědičnosti</emphasis>. Student střední školy dědí (vlastnosti a schopnosti) od studenta obecného. A student obecný dědí totéž od člověka. Příliš obecné? Pojďme to rozklíčovat:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Člověk má věk, výšku a váhu. Každý? Bezpochyby.</simpara>
</listitem>
<listitem>
<simpara>Má student věk, výšku a váhu? Opět bezpochyby. Student je tedy dědí od člověka. Student dále má navíc studijní průměr a dochází na různé předměty.</simpara>
</listitem>
<listitem>
<simpara>Má student střední školy studijní průměr a předměty? Ano, opět ano. Každý student střední školy má tyto atributy. Student tedy dědí od obecného studenta. Má ale každý student maturitní zkoušku? Nebo studuje každý student na střední škole? Ne? Pak bychom museli náš model dále upravit.</simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="uml.png"/>
</imageobject>
<textobject><phrase>uml</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>Shrňme to. Student střední školy dědí (dědí ve smyslu přejímá stejné členy, čili vlastnosti a metody) od studenta obecného. A student obecný dědí od člověka. Od čeho by mohl dědit člověk? Třeba od savce (každý člověk je savec a má s&#160;nimi mnoho společného). S&#160;čím má něco společného savec? Se zvířetem. S&#160;čím zvíře? S&#160;jakoukoliv živou formou. Vidíte? Jsme stále obecnější a obecnější. A proto: není jedna živá forma (třída), není jedno zvíře (třída), není jeden člověk (zase třída!). Ale je pouze jeden (pro změnu) Láďa Novák, jakožto unikátní případ studenta.</simpara>
</note>
</section>
<section xml:id="_zapouzdření">
<title>Zapouzdření</title>
<simpara>Další tajemný pojem. Dotýká se ale vskutku prostých věcí. Zůstaňme u našeho Igora. Víme, jak je vysoký? Víme (nebo snadno zjistíme). Víme, jak se chová? Víme. Dovedeme zjistit jeho reakce na konkrétní situace? Vskutku, Pavlov by mohl povídat, že. Zatím jsme se bavili o&#160;tom, jak se nám Igor (objekt, pamatujeme?) jeví navenek. Jaký je ale Igor uvnitř? A zajímá nás to vůbec?</simpara>
<orderedlist numeration="arabic">
<title>Na tomto místě se opět dostáváme k&#160;podstatě věci. Zajímat nás to může, ale nemusí:</title>
<listitem>
<simpara>Co když chceme pouze spolupracovat s&#160;Igorem (stále objekt) na konkrétním úkolu? Pak nás zajímá, jak dobré má pracovní výkony, jak se projevuje v rámci kolektivu, jak reaguje. Zajímá nás jeho rozhraní (ano, to je už termín z&#160;objektového programování stvořený pro tento účel).</simpara>
</listitem>
<listitem>
<simpara>Zajímá nás ale, jaký je Igor uvnitř? Igor (objekt) je odvozen ze člověka (třída) a jako kterýkoliv jiný, je unikátní. Ale k tomu podstatnému. K&#160;čemu vědět jak pracují jeho játra? Srdce? Jaký je jeho krevní tlak?</simpara>
</listitem>
</orderedlist>
<simpara>U&#160;objektového programování nás zajímá, jak se kdo (konkrétní objekt) chová a jaké má vlastnosti. Proč se tak chová a proč má jaké vlastnosti, je nám lhostejné. Co když ale sami vytváříme nějaký určitý (ha, ne objekt, ale jeho popis, čili co? Ano, třídu!)? Pak musíme přesně určit, proč se co a jak chová a jaké je to uvnitř. Jaké vlastnosti a schopnostmi má (třeba člověk, byli-li bychom schopni ho vytvořit, že) skryté uvnitř a <emphasis role="strong">kterými se má naopak projevovat navenek</emphasis>.</simpara>
<simpara>To je podstata <emphasis role="strong">zapouzdření</emphasis>. Každá třída má vlastnosti a metody (kolonky, vzpomínáte), které jsou  dostupné buď čistě uvnitř ní samotné (pak bychom je nazvali privátní, popř. označili jako <literal>protected</literal>), nebo takové, kterými se na základě třídy vytvořený objekt projevoval navenek. Ty by pak tvořili jeho rozhraní (a museli by být tzv. veřejné). Zdůrazněme to znovu, třída (třeba člověk) se navenek nijak projevovat nebude, ale Igor, jakožto instance této třídy (objekt), už může být moc zajímavý (mít vlastnosti a metody).</simpara>
<simpara>Jasné? Pojďme si to zkomplikovat :-)</simpara>
</section>
<section xml:id="_co_jsou_to_modifikátory_přístupu">
<title>Co jsou to modifikátory přístupu</title>
<simpara>Co označujeme za členy třídy už víte. Zapouzdření znáte také. Každému členovi třídy je možné nastavit určitý modifikátor přístupu. Zamyslete se nad tím spojením. Modifikujeme přístup. Říkáme, <emphasis role="strong">odkud ke členu dané třídy smí přistoupit</emphasis> a odkud ne. Běžně se s&#160;nimi setkáváte (v&#160;C# prakticky ani nemůžete jinak), už od  prvního spuštění vývojového prostřední vidíte slova jako <literal>public</literal>, <literal>private</literal> a mnohá jiná. Nyní se podíváme na ty nejpodstatnější ze základních (a zároveň i nejčastěji používaných).</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>K čemu slouží <literal>private</literal>? Použijete ho, když chcete docílit toho, aby daný člen byl dostupný pouze v&#160;rámci třídy a dost. Vytvoříte na základě třídy objekt? Pak člen nebude dostupný navenek. Podědíte ze třídy? Opět smůla, nedostanete se k němu.</simpara>
</listitem>
<listitem>
<simpara>Jak je to u <literal>protected</literal>? Podobné jako v&#160;předchozím případě, ale s&#160;důležitým rozdílem. Člen bude dostupný ve všech třídách, které ze třídy, kde je umístěn váš člen, dědí. Bude dostupný i navenek? Stále ne, k tomu je třeba další z&#160;našeho výčtu.</simpara>
</listitem>
<listitem>
<simpara>A to konkrétně modifikátor přístupu <literal>public</literal>. Je samopopisný: je veřejný. Takovýto člen bude vždy poděděn a zároveň bude vidět navenek u na základě třídy vytvořeného objetu. Ano, bude tvořit jeho <emphasis role="strong">rozhraní</emphasis>. Právě v&#160;duchu kapitolek o&#160;pár řádků výše.</simpara>
</listitem>
</orderedlist>
<screen>/* Demonstrace modifikátorů přístupu */

namespace NeskodnyCsharp
{
    class Clovek
    {
        private int ID; // Vlastnost je přístupná pouze ve třídě Clovek
        protected int Vyska;    // Vlastnost je možné zdědit
        public int Vek; // Vlastnost může tvořit rozhraní objektu
    }

    class Student : Clovek
    {
        public Student()
        {
            Vyska = 188;    // Lze přistupovat k poděděné vlastnosti
            /* Inicializace nového objektu na základě třídy Clovek */
            Clovek muz = new Clovek ();
            muz.Vek = 27;   // Přístup k vlasnoti 'Vek' tvořící rozhraní objektu
        }
    }

}</screen>
<simpara>Vždy, když nějaký prvek chcete použít, zamyslete se nad tím, zda ho aktuálně použít můžete. Není-li modifikátor přístupu určen, automaticky se použije <literal>private</literal>, čili nejpřísnější možná varianta. Pozor na to, jedná se o odlišnost od mnoha jiných jazyků (jako třeba Java), kde mohou být jiné zvyklosti.</simpara>
<note>
<simpara>Pakliže váháte nad tím, který modifikátor přístupu u&#160;vámi vytvářeného členu použít, odpovězte si na otázku: Kde a kdo musí nezbytně tento prvek vidět? Snažte se nastavit tuto úroveň na spíše přísnou než naopak. Snáze opravíte chybu, když někomu (nebo něčemu) dáte oprávnění málo (věřte, on se ozve), než chybu, kde oprávnění k&#160;přístupu byla až příliš široká (ten údržbář asi opravdu neměl mít přístup k ovládání reaktoru&#8230;&#8203;). Prostě, buďte opatrní (neslyšíte to naposledy).</simpara>
</note>
</section>
</chapter>
<chapter xml:id="_jaké_známe_druhy_tříd">
<title>Jaké známe druhy tříd</title>
<section xml:id="_popis_jednotlivých_tříd">
<title>Popis jednotlivých tříd</title>
<simpara>S pojmem třída jsme se tedy už střetli. <emphasis role="strong">Vzor, šablona, popis</emphasis>. To jsou slova, která udržte v paměti. Budeme je potřebovat. Na řádcích o&#160;kousek výše jsme si popsali, jak se třída může chovat. Jednalo se o&#160;klasický případ, kdy na základě „vyplnění formuláře“ vytváříme konkrétní objekt. Takovou třídu si můžeme nazvat řekněme „klasickou“. Mnoho o&#160;ní ale zatím nevíme.</simpara>
<section xml:id="_klasická_třída">
<title>Klasická třída</title>
<simpara>Obecná, obyčejná, prostě základ, ze kterého vycházíme. Stále rozvíjíme situaci popsanou výše. Pojďme se podívat na to, kde a jak danou třídu definovat, a jak se přiblížit její implementaci v programovacím jazyce C#. Jistě jste si všimli, že když založíme nový projekt, dojde k vytvoření minimálně jednoho souboru, ve kterém se vyskytuje jmenný prostor (<literal>namespace</literal>), uvnitř něhož je&#8201;&#8212;&#8201;typicky&#8201;&#8212;&#8201;definována jedna třída. Co s&#160;tím?</simpara>
<simpara>Jmenný prostor je oblast, ve které na sebe jednotlivé třídy "vidí". Když vytvoříme jmenný prostor <literal>Maturita</literal> a uvnitř něho třídy <literal>Komise</literal>, <literal>Student</literal> a <literal>Zkousejici</literal> mohou na sebe (bez dalšího) bez problémů vidět. Existovat vedle sebe a čekat než někdo vytvoří jejich instance, čili objekty. Na základně třídy <literal>Maturita</literal> např. objekt maturita2015, na základě třídy <literal>Zkousejici</literal> např. <literal>kotekDrsnyUcitel</literal> a podobně.</simpara>
<orderedlist numeration="arabic">
<title>Rozveďme si odpověď na otázku, kde třídy definovat:</title>
<listitem>
<simpara>Nejčastější situace je, ce které používáme jeden soubor, uvnitř něhož je definována právě jedna třída, která se nachází v&#160;rámci jednoho jmenného prostoru. Jsou programovací jazyky, které to ani jiným způsobem neumí a vyžadují právě striktní situaci aneb jedna třída uvnitř jednoho prostoru (a má to svou logiku a smysl např. z&#160;hlediska přehlednosti).</simpara>
</listitem>
<listitem>
<simpara>Druhá možnost je mít uvnitř jednoho souboru v&#160;*jednom jmenném prostoru více tříd*. Typicky je to vhodné v&#160;situaci, kdy chceme tyto jednotlivé třídy využít relativně jednoduchým způsobem. Naopak si představte, že byste měli dvě třídy v&#160;jediném souboru a chtěli je souběžně editovat. Vskutku, to není hezká představa skákat neustále, řekněmě, z&#160;řádku 353 na řádek 27, není-liž pravda?</simpara>
</listitem>
<listitem>
<simpara>A pak je tu situace třetí. Můžeme mít dva soubory sdílející jeden a ten samý jmenný prostor, ve kterých je obsažena právě jedna (ano jedna jediná) třída. Bavíme se pak, poměrně logicky, o tzv. částečné&#8201;&#8212;&#8201;partial&#8201;&#8212;&#8201;třídě. I tato situace může mít spoje opodstatnění. Poměrně běžný je případ, kdy v jedné partial třídě je generovaný kód (pokud jste někdy pracovali, ve Windows Forms, znáte to dobře) a ve druhé kód, kterým pak ručně rozšiřujeme (doplňujeme) kód ze souboru prvního. Důležité je si uvědomit, že pouze dohromady je vytvořena jedna celistvá třída s&#160;jedním názvem.</simpara>
</listitem>
</orderedlist>
<screen>/* Demonstrace částečných 'partial' tříd */

namespace NeskodnyCsharp
{
    /**
     * Každá z 'partial' tříd může být v jiném souboru,
     * ale musí být ve stejném namespace
    */

    partial class Clovek
    {
        public int Vek;
    }

    partial class Clovek
    {
        public int Vyska;
    }

    class Program
    {
        public static void Main()
        {
            /* Inicializace nového objektu na základě třídy Clovek */
            Clovek muz = new Clovek();
            /* Lze přistupovat k oběma vlastnostem z obou 'partial' tříd */
            muz.Vek = 27;
            muz.Vyska = 189;
        }
    }
}</screen>
<note>
<simpara>Co si z&#160; odnést? Předně to, že není jedno správné řešení. Není žádné dobré versus špatné. Lepší nebo horší. Zahoďte tento způsob uvažování a omezte se na mnohem elegantnější: vhodné a nevhodné. Všechny zmíněné třídy mají své opodstatnění a své využití. Dbejte na to.</simpara>
</note>
</section>
<section xml:id="_abstraktní_třída">
<title>Abstraktní třída</title>
<simpara>Je třída, ze které nemůžete (a nechcete) vytvořit její instanci, <emphasis role="strong">nemůžete vytvořit objekt</emphasis>. Abstraktní třída je výrazně neužitečná bez toho, aby z&#160;ní někdo (nějaká jiná třída) dědila. Představte si, že máme třídu <literal>Firma</literal>. V každé firmě budeme chtít počítat platy, třída <literal>Firma</literal> by tedy měla mít logicky metodu (ano metodu, podívejme se o&#160;pár odstavců výše), která slouží k&#160;takovému výpočtu. Něco na způsob <literal>VypoctiMzdy</literal> (jak by se mohla jmenovat).</simpara>
<simpara>Položte si teď zásadní otázku: Víte, jak se budou počítat mzdy u&#160;každé jednotlivé firmy? Stejně? Sotva. Systém prémií, benefitů apod. bude v&#160;různých oblastech dost jiný. Takže pozor. Tvrdíme, že každá firma potřebuje nějakým způsobem mzdy počítat, ale že těžko nalezneme nějaký jednotící model. A to je ono! O tom jsou abstraktní třídy. Nemůžeme vytvořit objekt na základě třídy <literal>Firma</literal>, ale můžeme pevně předepsat, že každá třída, která z&#160;ní bude dědit, mzdy (už konkrétním zpsůobem) počítat musí. Musí obsahovat metodu <literal>VypoctiMzdy</literal>. Předepišme to tedy. Kde? No právě v abstraktní třídě. Která to je? V&#160;tomto případě právě třída <literal>Firma</literal>. Takže platí, že:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Abstraktní třída <literal>Firma</literal> bude obsahovat deklaraci (opět abstraktní) metody <literal>VypoctiMzdy</literal>. Pouze deklaraci (čistý fakt, že má existovat), nikoliv definici (jak to má konkrétně počítat). Ještě jednou: na základě této třídy nemůžeme vytvořit instanci (objekt).</simpara>
</listitem>
<listitem>
<simpara>Třídy (teď již „obyčejné“), které se mohou jmenovat např. <literal>Automobilka</literal> a <literal>Reklamni</literal>, které budou dědit z třídy <literal>Firma</literal>, pak budou muset každá obsahovat jinou definici metody <literal>VypoctiMzdy</literal>. Muset jako muset. Nebudou-li ji obsahovat, projekt ani nepůjde zkompilovat. Hotovo. Jak prosté, milý Watsone.</simpara>
</listitem>
</orderedlist>
<simpara>Abstraktní třídy tedy nebyly právě intelektuální výzvou, pojďme na třídy statické :-)</simpara>
</section>
<section xml:id="_statická_třída">
<title>Statická třída</title>
<simpara>Neslyšíte to už v&#160;jejím názvu? Statická třída. Neměnná třída. Hotová třída. Ani z&#160;této třídy <emphasis role="strong">nevytváříme objekty</emphasis>, u&#160;této třídy to hlavně ani dělat nechceme. Měli jste někdy potřebu vypsat nějaká data do konzole v&#160;přesně definovaném formátu? Nebo vícenásobně použít nějakou metodu, kterou jste jinde definovali? Tady jsme u&#160;toho. Opět si položte otázku: Má smysl, abyste definovali identickou např. metodu <literal>VypisVeSloupcich</literal> v&#160;deseti různých třídách? Asi řeknete ne, ale vyvstává tu logická námitka: Proč nemohu tuto metodu definovat ve třídě, ze které ostatní dědí?</simpara>
<simpara>Toto je zásadní moment. Proč ne? Vždyť to má svou logiku. Uvědomme si následující. Pokud mezi sebou třídy dědí, znamená to, že mezi sebou mají vztah, logickou návaznost, propojenost vztahu od obecného ke konkrétnímu. Od třídy <literal>Firma</literal> může dědit třída <literal>Automobilka</literal>, od třídy <literal>Automobilka</literal> třída <literal>CeskaAutomobilka</literal>. V pořádku? Dobrá. Asi se shodneme, že každá z&#160;těchto tříd by mohla chtít umět vypsat nějaká data ve sloupcích. Stále v&#160;pořádku? OK. Znamená to ale nutně, že třída <literal>Pracka</literal> dědící ze třídy <literal>Vyrobek</literal>, žádná taková data k vypsání nemá? Aha, jsme u&#160;toho.</simpara>
<orderedlist numeration="arabic">
<title>Problém je následující:</title>
<listitem>
<simpara>Metoda <literal>VypisVeSloupcich</literal>, která by byla obsažená ve třídách <literal>Firma</literal> a <literal>Vyrobek</literal>, by dělala přesně to samé a přesně ve stejných situacích. Pracovala by přesně se stejnými vstupními daty. Byla by stejná. Opakování se, opakování se, opakování se. To je přesně to, co nechceme. Pamatujme na to. Vždy, když narazíme na opakování, má nám to značit, že je něco špatně (a bohužel dost typicky a pravděpodobně na naší straně, to jest hoře programátorovo).</simpara>
</listitem>
<listitem>
<simpara>Správný postup je, jak název kapitoly napovídá, použít <emphasis role="strong">statickou</emphasis> třídu. Statická třída obsahuje výčet obecně použitelných metod nebo konstant, které chceme použít nezávisle na dalším. Naše statická třída by se tedy mohla jmenovat např. <literal>Vystup</literal> a metoda <literal>VypisVeSloupcich</literal> by jako argument mohla přebírat data jakéhokoliv objektu, která by bylo třeba v&#160;nějaký okamžik vypsat.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>Statická třída je tedy o&#160;výčtu. O&#160;znovupoužitelnosti. O&#160;použitelnosti nezávisle na určitých datech. Vypadá tajemně, ale není. Znáte třídu <literal>Math</literal>(měli byste)? Obsahuje metody pro výpočet sinu a konstanty, jako je např. PI. Zkoušeli jste si někdy vytvořit instanci třídy <literal>Math</literal>..? Asi tušíte kam směřuji, nešlo by to, je statická. Vztahuje se výpočet sinu a PI k jedné konkrétní oblasti? Ne? Oba prvky ale jistě použijeme v&#160;mnoha jiných situacích (konstrukce, analytická geometrie, energetika), až v&#160;desítkách či stovkách. Ne v&#160;jedné oblasti. Řekli jsme mnoho a vychází nám klasický kandidát na statickou třídu.</simpara>
</note>
</section>
</section>
<section xml:id="_klíčové_pojmy_k_třídám">
<title>Klíčové pojmy k třídám</title>
<section xml:id="_konstruktor">
<title>Konstruktor</title>
<simpara>Zatím jsme se drželi jen u&#160;těch nejzákladnějších termínů, pojďme se podívat na některé lehce specifičtější. Co je to konstruktor? Existuje na to extrémně stručná odpověď: metoda. Konstruktor je nicméně <emphasis role="strong">metoda, která je velmi zvláštní</emphasis>, a to následujícími věcmi:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Jmenuje se stejně jako třída, ve které je obsažena. Třída <literal>Skola</literal>, tedy bude obsahovat konstruktor s názvem <literal>Skola()</literal>.</simpara>
</listitem>
<listitem>
<simpara>Nemá žádný návratový typ. U&#160;obyčejné metody musíme určit minimálně už to, že metoda žádnou hodnotu nevrací (použijeme pak klíčové slovo <literal>void</literal>). U&#160;konstruktoru ne.</simpara>
</listitem>
<listitem>
<simpara>Je volána v&#160;okamžiku, kdy vytváříme konkrétní instanci třídy. Ano píšeme-li <literal>Skola ssps = new Skola()</literal>, pak výraz <literal>Skola()</literal> je konstruktorem této třídy.</simpara>
</listitem>
</orderedlist>
<simpara>K čemu je nám v&#160;praxi konstruktor dobrý? Znovu se vraťme k&#160;tomu, k&#160;čemu je nám třída. Je to prázdný formulář, který chceme vyplnit. Klíčové je ale <emphasis>kdy</emphasis>. Pokud bychom vytvořili objekt podle příkladu výše (v&#160;bodě 3), pak je to sice formulář s&#160;razítkem, ale stále poněkud smutně prázdný. Objekt existuje, ale je takový lejaký nijaký. Co s tím?</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Můžeme postupně přistoupit k&#160;veřejně přístupným (tedy <literal>public</literal>) vlastnostem objektu (tvořícím rozhraní objektu, pamatujeme?) a postupně určit, že <literal>ssps</literal> má takovéhoto ředitele, takovéto studenty apod. To je cesta první.</simpara>
</listitem>
<listitem>
<simpara>Nebo můžeme tyto údaje předat přímo konstruktoru jako argumenty. V&#160;okamžiku, kdy někdo vytváří objekt na základě třídy škola, je tímto donucen, aby alespoň minimální množství argumentů předal a prázdno vyplnil.</simpara>
</listitem>
</orderedlist>
<screen>/* Jak lze použít konstruktor */

namespace NeskodnyCsharp
{
    class Skola
    {
        /* Třídní proměnné Nazev a Adresa */
        public string Nazev;
        public string Adresa;

        /* Konstruktor třídy a jeho typické použití */
        public Skola(string naz, string adr)
        {
            /**
             * Přiřazení výchozích hodnot do třídních proměnných
             * pomocí přiřazení v konstruktoru
            */
            Nazev = naz;
            Adresa = adr;
        }
    }

    class Program
    {
        public static void Main()
        {
            /**
             * Vytvoření nového objektu 's' dle konstruktoru Skola()
             * třídy Skola s jeho argumenty
            */
            Skola s = new Skola("SPS", "Adresa 25, Praha");
        }
    }
}</screen>
<simpara>Protože programování není o&#160;uctívání svatých krav, můžeme oba přístupy kombinovat, třeba použít konstruktory více s&#160;různými požadovanými argumenty, pak se bavíme o&#160;přetěžování konstruktoru. (Chcete vědět víc? Podívejte se na kapitolu „Proč přetěžovat metody“.) Můžeme tak klidně definovat konstruktor, který nepřebírá žádný argument; který přebírá argument jeden, nebo další, který jich přebírá více. Co když ve třídě žádný konstruktor nepoužijeme? Je to prosté, pak se použije implicitní konstruktor, který sice nevidíme, ale je přítomen.</simpara>
</section>
<section xml:id="_slůvka_this_a_base">
<title>Slůvka „this“ a „base“</title>
<simpara>Co znamenají? Je dost pravděpodobné, že jste se s&#160;nimi někde v&#160;rámci tvořeného zdrojového kódu setkali. Neskrývá se za nimi nic tajemného. Běžně v&#160;rámci nějaké třídy voláme (nebo přistupujeme k) její člen. Nejčastěji ho voláme čistě jeho názvem (a v&#160;C# není mnoho situací, které by nás nutili k&#160;tomu dělat to jinak). Vrátíme-li se k&#160;naší třídě <literal>Clovek</literal> vidíme, že jsme pracovali se členem (zde atributem) značícím výšku (nazvěme ho tedy <literal>Vyska</literal>). Můžeme ho v&#160;rámci třídy volat jednoduše, tedy pouze <literal>Vyska</literal>, jako by to byla jakákoliv jiná proměnná. Stejně tak dobře ale můžeme napsat <literal>this.Vyska</literal>. Proč je tomu tak?</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Slovo <literal>this</literal> nám ukazuje na konkrétní instanci třídy, tedy objekt. Můžeme mít mnoho různých instancí třídy <literal>Clovek</literal> (Igora, Honzu, kohokoliv) a každá z&#160;nich v&#160;sobě bude obsahovat vlastnost <literal>Vyska</literal>. Zápisem <literal>this.Vyska</literal> říkáme, že se vztahujeme právě k&#160;tomuto konkrétnímu člověku a atributem <literal>Vyska</literal> k&#160;hodnotě poplatné právě a jen tomuto člověku.</simpara>
</listitem>
<listitem>
<simpara>Můžeme si to demonstrovat ještě jinak. Program, který není spuštěný, leží na pevném disku. Platí? V&#160;okamžiku, kdy ho spustíme, se stane procesem a získá svá specifika (přidělenou operační paměť, prioritu procesu) včetně konkrétních hodnot jeho atributů. V&#160;čem je klíčový fígl? Daný program můžete (typicky) spustit vícekrát, jedná se tedy o&#160;více spuštěných instancí (a slůvko <literal>this</literal> se vztahuje ke každému jednotlivému z nich).</simpara>
</listitem>
</orderedlist>
<simpara>Jak byl popis slůvka <literal>this</literal> vyčerpávající, popis slůvka <literal>base</literal> bude o&#160;to kratší. Týká se dědičnosti. V&#160;C# máme vždycky maximálně jednu třídu, ze které dědíme, ne více. A pojem <literal>base</literal> se vztahuje právě k&#160;ní. Může nastat situace, kdy budeme potřebovat sáhnout na nějaký člen obsažený právě v&#160;této třídě a přesně k&#160;tomu se <literal>base</literal> hodí. Ostatně to je přesně ten důvod, proč dané třídě říkáme <emphasis>bázová</emphasis>.</simpara>
<orderedlist numeration="arabic">
<title>Pojďme si možné situace ilustrovat na příkladu:</title>
<listitem>
<simpara>Třída <literal>Student</literal> dědí ze třídy <literal>Clovek</literal>. Uvěřitelný předpoklad. Budu-li si chtít sáhnout v&#160;rámci kódu ve třídě <literal>Student</literal> na atribut <literal>Vyska</literal> ve tvaru, ve kterém je obsažený ve třídě <literal>Clovek</literal>, napíšu poměrně přímočaře <literal>base.Vyska</literal>. Lehké, že?</simpara>
</listitem>
<listitem>
<simpara>Vaše úplně logická otázka pravděpodobně je, proč bychom něco takového vůbec měli dělat? Vždyť jsme obsah třídy <literal>Clovek</literal> podědili (ano, máme-li nastavené modifikátory přístupu minimálně na <literal>protected</literal>). Máte pravdu. Vtip je v&#160;tom, že ne vždy chceme v&#160;aktuální třídě použít poděděný člen přesně v&#160;takovém tvaru, ale chceme pracovat s&#160;oběma.</simpara>
</listitem>
<listitem>
<simpara>Zmatečné? Možná to tak na první pohled vypadá, ale všechno bude křišťálově čisté hned, jak se dostane k&#160;další kapitole o&#160;polymorfismu. Pro teď si zapamatujme, že s <literal>base</literal> se asi nejčastěji v&#160;C# setkáme, když chceme přebrat ze třídy, ze které dědíme, konstruktor a třeba ho mírně doplnit a rozšířit. Tajemné? Není, podívejte se na příklad níže.</simpara>
</listitem>
</orderedlist>
<screen>/* Jak prakticky využít 'base' a 'this' */

namespace NeskodnyCsharp
{
    class Clovek
    {
        public int Vyska;

        public Clovek(int vys)
        {
            /* Oba dva zápisy dělají naprosto totéž */
            this.Vyska = vys;
            Vyska = vys;    // Zkrácený tvar přiřazení
        }
    }

    class Student : Clovek
    {
        public string Skola;

        /**
         * Podědění bázového konstruktoru a jeho rozšíření
         * o další argument - určení školy
        */
        public Student(int vys, string sko) : base(vys)
        {
            Skola = sko;    // Opět, lze zapsat i jako this.Skola = sko;
        }
    }
}</screen>
<simpara>Vidíte, že na tom nic není. Námi nově vytvořený konstruktor (ve třídě <literal>Student</literal>) zbytečně <emphasis role="strong">neopakuje, co už dělá konstruktor v bázové třídě</emphasis> <literal>Clovek</literal> (to slůvko si pamatujme). Přebírá argumenty poplatné bázovému konstruktoru a předává mu je, zatímco sám nově vyžaduje pouze argument <literal>skola</literal>, který předává do třídní proměnné <literal>Skola</literal>. Pouze a jen to, žádný zbytečný kód navíc. (A co si budeme říkat, pouze a jedině tam má smysl. Chodí snad každý člověk stále do školy?)</simpara>
</section>
</section>
</chapter>
<chapter xml:id="_k_čemu_slouží_a_co_je_to_polymorfismus">
<title>K čemu slouží a co je to polymorfismus</title>
<section xml:id="_proč_přetěžovat_metody">
<title>Proč přetěžovat metody</title>
<simpara>Protože chceme pro metody používat hezké a dobře <emphasis role="strong">zapamatovatelné názvy</emphasis>. A spolu s tím -– protože naopak nechceme používat mnoho podobných (a lehce zaměnitelných) názvů. To je podstatou. Z&#160;čeho ale vyplývá taková potřeba? Můžeme chtít mít v&#160;našem programu metody, které dělají principiálně totéž, ale přebírají různý počet argumentů. Jak by to tedy mohlo vypadat?</simpara>
<orderedlist numeration="arabic">
<title>Pojďme přijít na nějaký příklad:</title>
<listitem>
<simpara>Metoda, která vypisuje počet sekund na základě vstupních dat, by se mohla nazývat, řekněme, <literal>VypisSekundy</literal>. Co by taková metoda mohla přebírat na vstupu jako argument? Dny? Hodiny? Minuty? Dny a hodiny? Dny, hodiny a minuty?</simpara>
</listitem>
<listitem>
<simpara>Pro každou z těchto situací bychom dovedli vymyslet hezký název. Něco a la <literal>VypisSekundyNaZakladeHodin</literal>, <literal>VypisSekundyNaZakladeHodinMinut</literal>. Už teď si je nepamatujete, že? Přitom původní název <literal>VypisSekundy</literal> je zapamatovatelný dokonale. A tady nastupuje přetěžování, my tento název vícenásobně použít opravdu můžeme.</simpara>
</listitem>
<listitem>
<simpara>Pozor, <emphasis role="strong">přetěžování není všespásné</emphasis>. Použijeme ho, když máme různý počet argumentů, nebo když máme argumenty jiného typu. Kdybychom chtěli přetížit název metody <literal>VypisSekundy</literal> a na vstupu předávat jako jeden argument v prvním případě počet minut (jako celé číslo), ve druhém pak počet hodin (zase jako celé číslo), máme smůlu.</simpara>
</listitem>
</orderedlist>
<simpara>Chtěl jsem napsat dlouhý vysvětlující odstavec, ale podívejte se raději o pár odstavců níže. Není tam uvedený kód jasný? Máme hezké zapamatovatelné názvy metod? Máme. Mají metody různý počet argumentů? Opět ano. Takže jsme právě viděli podstatu přetěžování. A o&#160;tom to je.</simpara>
</section>
<section xml:id="_kdy_použít_překrývání">
<title>Kdy použít překrývání</title>
<simpara>Všimněte si, že dosud jsme se pohybovali pouze v&#160;rámci jedné třídy. Všechny přetížené metody tam byly obsaženy hezky pěkně pod sebou. Tak to ale být nemusí. Je úplně běžná situace, že chceme nějakou metodu podědit, ale použít jinak. (A ano tohle je přesně to místo, které by vás mělo začít zajímat po odskoku od nyní již známého slůvka <literal>base</literal>.) Může to být libovolná metoda, klidně včetně konstruktoru.</simpara>
<orderedlist numeration="arabic">
<title>Klasikou v tomhle směru je v&#160;C# metoda na převod čehokoliv na řetězec:</title>
<listitem>
<simpara>Aneb <literal>ToString</literal>. Naleznete ji u&#160;jakéhokoliv objektu, takže v&#160;podstatě u&#160;všeho. Proč? Její definice je obsažena ve třídě <literal>Object</literal> a z&#160;této třídy dědí doslova všechny další třídy. Všechny. Na počátku je vždy ona. Chová se ale metoda <literal>ToString</literal> stejně u&#160;objektu typu <literal>Int32</literal> i&#160;u, řekněme, objektu typu <literal>Button</literal>?</simpara>
</listitem>
<listitem>
<simpara>Odpověď asi tušíte. Ne, chovají se jinak. Jak převést číslo na řetězec? Jednoduše. Ale tlačítko na řetězec? Uff, to už vypadá na netriviální problém. Logicky postupně dospějeme k&#160;tomu, že jak ve třídě <literal>Int32</literal>, tak <literal>Button</literal>, bude mít metoda <literal>ToString</literal> mít svou definici, ale ta bude zároveň v&#160;každé třídě jiná. Jiná, i když obě dědí ze třídy <literal>Object</literal>. A zde nastupuje překrývání.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>Kdy tedy překrývání použít? Vždy, když chceme použít nějaký název znovu v&#160;rámci hierarchie dědičnosti. A z&#160;dobrého důvodu. Používejme tuto možnost vždy, když víme, co děláme, jinak se stane zbraní hromadného ničení. (Ale lze celkem úspěšně předpokládat, že taková raketa typu Trident bude programována spíše v&#160;Adě než v&#160;C#.) Pohybujeme se tedy po linii dědičnosti, vertikálně. Horizontální pohyb by zde byl čím? Správně, přetěžováním.</simpara>
</note>
<section xml:id="_virtuální_a_abstraktní_metody">
<title>Virtuální a abstraktní metody</title>
<simpara>Máme tedy bázovou třídu, ze které dědíme. V&#160;té máme metodu, jejíž název chceme dále -– ve třídě, která z&#160;ní bude dědit –- použít. Tyto metody chceme nějak označit, dát najevo, že mohou (nebo musí) být ve třídě z&#160;bázové dědící předefinovány (nebo definovány). Použijeme pro to dvě klíčová slůvka a to <literal>virtual</literal> a <literal>abstract</literal>. Bavíme se pak o&#160;virtuální a abstraktní metodě. Povědomé? Ano. Přesně, už jsme se o tom bavili v&#160;kapitole o&#160;abstraktních třídách a toto povídání na ni přesně navazuje.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis role="strong">Virtuální metoda</emphasis> je metoda, u&#160;které dáváme najevo, že může, ale nemusí, být překryta. Dáváme, sami sobě, nebo jinému programátorovi, najevo, že se scénářem překrytí takovéto metody se prostě počítá.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Abstraktní metodu</emphasis> bychom už měli znát. Ta nejenom, že může. Ne, ta musí být definována. V&#160;bázové třídě je obsažen pouze popis, že má existovat metoda s&#160;určitým názvem a přebírat nějaké argumenty. Je deklarovaná. Její definice ale musí přijít až ve třídě, která z&#160;ní podědí.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Asi vás napadnou dva možné scénáře:</title>
<listitem>
<simpara>Co když slůvko <literal>virtual</literal> neuvedu? Moderní kompilátory do bytecode (nebo přesněji do CIL) vám to pravděpodobně povolí a funkčnost bude opticky identická, nicméně nedělejme to. Je to příklad benevolence, který se nemusí vždy vyplatit.</simpara>
</listitem>
<listitem>
<simpara>Co když metodu, která je uvedena jako abstraktní, dále (po podědění) nedefinuji? Tady to je prosté. Váš kód nepůjde zkompilovat. Hotovo. Chybové hlášení, které to popisuje, je ale velmi přesné. Nemusíte se bát. Uvidíte a opravíte.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_logika_klíčových_slov_override_a_new">
<title>Logika klíčových slov override a new</title>
<simpara>Zatím jsme se pohybovali na úrovni definic (nebo deklarací) metod, které můžeme (nebo musíme) překrýt. Jak je to ale na druhé straně? U&#160;tříd, které z&#160;nich dědí? Stejně tak, jako dáváme najevo, že povolujeme překrytí metody, musíme dát najevo, že danou metodu překrýváme (nebo definujeme). I&#160;tady máme klíčová slova, nyní v&#160;podobě pojmů <literal>new</literal> a <literal>override</literal>. Jak na ně?</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Použijeme-li klíčové slovo <literal>override</literal>, říkáme, že metoda, kterou právě chceme napsat, bude zachovávat logiku té, kterou překrýváme. Neměníme <emphasis role="strong">její smysl</emphasis>. Neměníme její <emphasis role="strong">návratový typ</emphasis>. <literal>ToString</literal> by vždy měla převádět něco na řetězec. Ne vždy to ale bude dělat tím jediným správným způsobem. Proto překrýváme. To dává smysl, že?</simpara>
</listitem>
<listitem>
<simpara>A co když je to „nové“? Kdy použít <literal>new</literal>? To je vzácnější situace. Někdy můžeme chtít použít už existující název metody pro zcela novou věc. Ve zcela nové situaci. Pro metodu, která se <emphasis role="strong">liší od oné překrývané smyslem i návratovým typem</emphasis>. Představte si, že by metoda <literal>ToString</literal> vracela celé číslo, které by odpovídalo nějakému matematickému výpočtu. To by ale nedávalo smysl, že? Dobře si rozmyslete, jestli něco takového chcete udělat.</simpara>
</listitem>
</orderedlist>
<screen>/* Demonstrace překrývání a přetěžování */

using System;

namespace NeskodnyCsharp
{
    class Clovek
    {
        public int Vyska;

        /* Virtuální metoda, kterou je možné přerýt */
        public virtual string VypisUdaje()
        {
            return Vyska.ToString ();
        }
    }

    class Student : Clovek
    {
        public string Skola;

        /* Metoda, která překrývá bázovou metodu 'VypisUdaje' */
        public override string VypisUdaje ()
        {
            return String.Format ("{0} {1}", Vyska, Skola);
        }

        /* Metoda, která přetěžuje metodu 'VypisUdaje' - má jiný počet argumentů */
        public override string VypisUdaje (bool vsechno)
        {
            if (vsechno)
            {
                return String.Format ("{0}, {1}", Vyska, Skola);
            }
            else
            {
                return Skola;
            }
        }
    }
}</screen>
<simpara>A opět si rozebereme příklad. Pozorně se podívejte na komentáře, které jsou v&#160;něm obsažené. Překrývání nám obecně může ušetřit mnoho práce, může usnadnit a zpřehlednit náš kód už tím, že v&#160;něm budou použity komukoliv známé názvy metod, které budou dělat správně to, co se od nich běžně očekává. Ale ještě jednou zopakuji. Opatrně. Používejte překrývání, jen když má smysl.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="_jak_se_pracuje_s_rozhraními">
<title>Jak se pracuje s rozhraními?</title>
<section xml:id="_význam_rozhraní">
<title>Význam rozhraní</title>
<simpara>Aneb mikrokapitola na závěr. S&#160;pojmem rozhraní jsme se už setkali. Můžeme ho použít v&#160;obecném smyslu, právě tak jsme o&#160;něm ostatně již mluvili. Objekt má nějaké rozhraní. Klasika. V&#160;programovacím jazyce C# však ale máme ještě další nástroj pro to, jak s&#160;rozhraními pracovat. Jakýsi předpis, který nám říká, že musíme v&#160;dané třídě implementovat konkrétní metody. Tento předpis se nazývá <emphasis role="strong">interface</emphasis>, čili do češtiny přeloženo: rozhraní. Jestliže vám to připomíná pojetí abstraktních tříd, je to zcela správná úvaha, nicméně rozhraní nejsou přesnou analogií. Proč tomu tak je?</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Vzpomeňte si, že v&#160;C# můžete <emphasis role="strong">dědit pouze a výhradně z&#160;jedné třídy</emphasis>. Tečka. Včetně abstraktních tříd. To je velmi omezující. Chtěli byste podědit z&#160;naší známé třídy <literal>Clovek</literal> a zároveň z&#160;abstraktní třídy <literal>Chovani</literal>? Smůla, jakkoliv by to mělo svou logiku.</simpara>
</listitem>
<listitem>
<simpara>Rozhraní nicméně můžeme <emphasis role="strong">implementovat tolik, kolik chceme</emphasis>. Kdyby naše třída měla dědit ze třídy <literal>Clovek</literal> a implementovat rozhraní <literal>Chovani</literal>, šlo by to? Bez potíží. A klidně by mohla pokračovat implementováním dalších rozhraní. A že u&#160;člověka si lze představit mnoho předpisů, které každý jednotlivec musí splnit&#8230;&#8203;</simpara>
</listitem>
</orderedlist>
<screen>/* Demonstrace použití rozhraní */

using System;

namespace NeskodnyCsharp
{
    interface Chovani
    {
        /* Sada metod, které musí být implementovány */
        void Mluvit ();
        void Myslet ();
    }

    class Clovek
    {
        public string Jmeno;
    }

    /**
     * Třída 'Student' dědí ze třídy člověk a zároveň implementuje
     * předepsané rozhraní 'Chovani'
    */
    class Student : Clovek, Chovani
    {
        /* Nezbytné definice předepsaných metod */
        public void Mluvit()
        {
            Console.WriteLine (Jmeno + ": Mluvím!");
        }

        public void Myslet()
        {
            Console.WriteLine (Jmeno + ": Myslím!");
        }
    }
}</screen>
<simpara>Příklad výše nám tedy jasně ukazuje, o&#160;čem rozhraní jsou. Bylo nařízeno implementovat určitou sadu metod? Bylo. Podařilo se tyto metody implementovat? Podařilo. Pak gratuluji, dostali jste se k závěru našeho povídání.</simpara>
</section>
</chapter>
<chapter xml:id="_závěr">
<title>Závěr</title>
<simpara>(Ne)škodný úvod do pojetí objektového programování v&#160;prostředí programovacího jazyka C# máte nyní za sebou. Ale to by neměl být konec. Zpochybňujte. Dohledávejte další zdroje. Hledejte změny. Porovnávejte se situací v&#160;jiných jazycích. Ne všechny programovací jazyky mají svůj objektový model založený na třídách (podívejte se na Javascript a jeho pojetí OOP přes prototypy), ne všechny jazyky mají rozhraní a zakazují vícenásobnou dědičnost (Python). Ne všechny jazyky znají modifikátory přístupu (opět je jich mnoho). A šlo by pokračovat.</simpara>
<simpara>V době, kdy tento text čtete, už může být vývoj objektového programování (a zdaleka nejen toho) na místě, který byste vy a já nečekali. A proto Shrnu v&#160;jedné větě: <emphasis role="strong">Nebuďte statičtí</emphasis>, nezůstávejte na místě.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
<simpara>&#169; Lukáš Kotek 2015, <link xlink:href="https://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA 4.0</link></simpara>
</chapter>
</book>